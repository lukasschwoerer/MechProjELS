var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"RealTimeMachine","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"RealTimeMachine.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Global variables used by function prototype control */\r\n\r\n  /* '<Root>/SpindelPos' */\r\n  static uint32_T arg_SpindelPos = 0U;\r\n\r\n  /* '<Root>/CountFactor' */\r\n  static real_T arg_CountFactor = 0.0;\r\n\r\n  /* '<Root>/System_Trigger' */\r\n  static uint16_T arg_System_Trigger[2] = { 0U, 0U };\r\n\r\n  /* '<Root>/DesSteps' */\r\n  static uint16_T arg_DesSteps;\r\n\r\n  /* '<Root>/Dir' */\r\n  static uint16_T arg_Dir;\r\n\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n  enableTimer0Interrupt();\r\n  RealTimeMachine_step(arg_SpindelPos, arg_CountFactor, arg_System_Trigger,\r\n                       &arg_DesSteps, &arg_Dir);\r\n\r\n  /* Get model outputs here */\r\n  disableTimer0Interrupt();\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.0001;\r\n  float systemClock = 100;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  c2000_flash_init();\r\n  init_board();\r\n\r\n#ifdef MW_EXEC_PROFILER_ON\r\n\r\n  config_profilerTimer();\r\n\r\n#endif\r\n\r\n  ;\r\n  ((void) 0);\r\n  RealTimeMachine_initialize();\r\n  globalInterruptDisable();\r\n  configureTimer0(modelBaseRate, systemClock);\r\n  runModel = true;\r\n  enableTimer0Interrupt();\r\n  globalInterruptEnable();\r\n  while (runModel) {\r\n  }\r\n\r\n  globalInterruptDisable();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RealTimeMachine.c","type":"source","group":"model","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RealTimeMachine.c\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"RealTimeMachine.h\"\r\n#include \"RealTimeMachine_private.h\"\r\n\r\n/* Named constants for Chart: '<Root>/Chart' */\r\n#define RealTimeMachine_event_POR      (1L)\r\n#define RealTimeMachine_event_Takt     (0L)\r\n#define RealTimeMach_IN_NO_ACTIVE_CHILD (0U)\r\n#define RealTimeMachine_IN_Disabled    (1U)\r\n#define RealTimeMachine_IN_Enabled     (2U)\r\n#define RealTimeMachine_IN_Main        (1U)\r\n#define RealTimeMachine_IN_Reset       (2U)\r\n\r\n/* Block signals (default storage) */\r\nB_RealTimeMachine_T RealTimeMachine_B;\r\n\r\n/* Block states (default storage) */\r\nDW_RealTimeMachine_T RealTimeMachine_DW;\r\n\r\n/* Previous zero-crossings (trigger) states */\r\nPrevZCX_RealTimeMachine_T RealTimeMachine_PrevZCX;\r\n\r\n/* Forward declaration for local functions */\r\nstatic void Re_chartstep_c3_RealTimeMachine(const int32_T *sfEvent);\r\n\r\n/* Function for Chart: '<Root>/Chart' */\r\nstatic void Re_chartstep_c3_RealTimeMachine(const int32_T *sfEvent)\r\n{\r\n  /* Chart: '<Root>/Chart' incorporates:\r\n   *  Constant: '<Root>/Constant'\r\n   */\r\n  /* During: Chart */\r\n  if (RealTimeMachine_DW.is_active_c3_RealTimeMachine == 0U) {\r\n    /* Entry: Chart */\r\n    RealTimeMachine_DW.is_active_c3_RealTimeMachine = 1U;\r\n\r\n    /* Entry Internal: Chart */\r\n    /* Transition: '<S1>:12' */\r\n    RealTimeMachine_DW.is_c3_RealTimeMachine = RealTimeMachine_IN_Reset;\r\n\r\n    /* Entry 'Reset': '<S1>:1' */\r\n    RealTimeMachine_B.Enable = 0U;\r\n  } else if (RealTimeMachine_DW.is_c3_RealTimeMachine == 1U) {\r\n    /* During 'Main': '<S1>:2' */\r\n    /* During 'MachineStatus': '<S1>:101' */\r\n    if (RealTimeMachine_DW.is_MachineStatus == 1U) {\r\n      /* During 'Disabled': '<S1>:100' */\r\n      if (RealTimeMachine_P.Constant_Value == 0U) {\r\n        /* Transition: '<S1>:104' */\r\n        RealTimeMachine_DW.is_MachineStatus = RealTimeMachine_IN_Enabled;\r\n\r\n        /* Entry 'Enabled': '<S1>:98' */\r\n        RealTimeMachine_B.Enable = 1U;\r\n      }\r\n\r\n      /* During 'Enabled': '<S1>:98' */\r\n    } else if (RealTimeMachine_P.Constant_Value == 1U) {\r\n      /* Transition: '<S1>:103' */\r\n      RealTimeMachine_DW.is_MachineStatus = RealTimeMachine_IN_Disabled;\r\n\r\n      /* Entry 'Disabled': '<S1>:100' */\r\n      RealTimeMachine_B.Enable = 0U;\r\n    }\r\n\r\n    /* During 'Reset': '<S1>:1' */\r\n  } else if (*sfEvent == RealTimeMachine_event_POR) {\r\n    /* Transition: '<S1>:9' */\r\n    RealTimeMachine_DW.is_c3_RealTimeMachine = RealTimeMachine_IN_Main;\r\n\r\n    /* Entry Internal 'Main': '<S1>:2' */\r\n    /* Entry Internal 'MachineStatus': '<S1>:101' */\r\n    /* Transition: '<S1>:108' */\r\n    RealTimeMachine_DW.is_MachineStatus = RealTimeMachine_IN_Enabled;\r\n\r\n    /* Entry 'Enabled': '<S1>:98' */\r\n    RealTimeMachine_B.Enable = 1U;\r\n  } else {\r\n    RealTimeMachine_B.Enable = 0U;\r\n  }\r\n\r\n  /* End of Chart: '<Root>/Chart' */\r\n}\r\n\r\n/* Model step function */\r\nvoid RealTimeMachine_step(uint32_T arg_SpindelPos, real_T arg_CountFactor,\r\n  uint16_T arg_System_Trigger[2], uint16_T *arg_DesSteps, uint16_T *arg_Dir)\r\n{\r\n  real_T DesSteps_tmp;\r\n  int32_T sfEvent;\r\n  uint32_T SpindelDiv;\r\n  uint32_T qY;\r\n  uint32_T qY_tmp;\r\n  int16_T tmp;\r\n  int16_T tmp_0;\r\n  boolean_T zcEvent;\r\n  boolean_T zcEvent_idx_0;\r\n\r\n  /* Chart: '<Root>/Chart' incorporates:\r\n   *  TriggerPort: '<S1>/input events'\r\n   */\r\n  /* Inport: '<Root>/System_Trigger' */\r\n  zcEvent_idx_0 = (((arg_System_Trigger[0] > 0U) !=\r\n                    (RealTimeMachine_PrevZCX.Chart_Trig_ZCE[0] == POS_ZCSIG)) &&\r\n                   (RealTimeMachine_PrevZCX.Chart_Trig_ZCE[0] !=\r\n                    UNINITIALIZED_ZCSIG));\r\n  zcEvent = (((arg_System_Trigger[1] > 0U) !=\r\n              (RealTimeMachine_PrevZCX.Chart_Trig_ZCE[1] == POS_ZCSIG)) &&\r\n             (RealTimeMachine_PrevZCX.Chart_Trig_ZCE[1] != UNINITIALIZED_ZCSIG));\r\n  if (zcEvent_idx_0 || zcEvent) {\r\n    /* Inport: '<Root>/System_Trigger' */\r\n    tmp_0 = (int16_T)(zcEvent_idx_0 ? (int16_T)arg_System_Trigger[0] > 0 ?\r\n                      RISING_ZCEVENT : FALLING_ZCEVENT : NO_ZCEVENT);\r\n    tmp = (int16_T)(zcEvent ? (int16_T)arg_System_Trigger[1] > 0 ?\r\n                    RISING_ZCEVENT : FALLING_ZCEVENT : NO_ZCEVENT);\r\n\r\n    /* Gateway: Chart */\r\n    if (((tmp_0 & 128U) != 0U ? tmp_0 | -128 : tmp_0 & 127) != 0) {\r\n      /* Event: '<S1>:49' */\r\n      sfEvent = RealTimeMachine_event_Takt;\r\n      Re_chartstep_c3_RealTimeMachine(&sfEvent);\r\n    }\r\n\r\n    if (((tmp & 128U) != 0U ? tmp | -128 : tmp & 127) == 1) {\r\n      /* Event: '<S1>:50' */\r\n      sfEvent = RealTimeMachine_event_POR;\r\n      Re_chartstep_c3_RealTimeMachine(&sfEvent);\r\n    }\r\n  }\r\n\r\n  /* Inport: '<Root>/System_Trigger' */\r\n  RealTimeMachine_PrevZCX.Chart_Trig_ZCE[0] = (ZCSigState)(arg_System_Trigger[0]\r\n    > 0U);\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\r\n   *  TriggerPort: '<S2>/input events'\r\n   */\r\n  zcEvent_idx_0 = (((arg_System_Trigger[0] > 0U) !=\r\n                    (RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[0] ==\r\n                     POS_ZCSIG)) &&\r\n                   (RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[0] !=\r\n                    UNINITIALIZED_ZCSIG));\r\n\r\n  /* Chart: '<Root>/Chart' incorporates:\r\n   *  TriggerPort: '<S1>/input events'\r\n   */\r\n  RealTimeMachine_PrevZCX.Chart_Trig_ZCE[1] = (ZCSigState)(arg_System_Trigger[1]\r\n    > 0U);\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\r\n   *  TriggerPort: '<S2>/input events'\r\n   */\r\n  zcEvent = (((arg_System_Trigger[1] > 0U) !=\r\n              (RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[1] == POS_ZCSIG))\r\n             && (RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[1] !=\r\n                 UNINITIALIZED_ZCSIG));\r\n  if (zcEvent_idx_0 || zcEvent) {\r\n    /* Inport: '<Root>/System_Trigger' */\r\n    tmp_0 = (int16_T)(zcEvent_idx_0 ? (int16_T)arg_System_Trigger[0] > 0 ?\r\n                      RISING_ZCEVENT : FALLING_ZCEVENT : NO_ZCEVENT);\r\n    tmp = (int16_T)(zcEvent ? (int16_T)arg_System_Trigger[1] > 0 ?\r\n                    RISING_ZCEVENT : FALLING_ZCEVENT : NO_ZCEVENT);\r\n    if (((tmp_0 & 128U) != 0U ? tmp_0 | -128 : tmp_0 & 127) != 0) {\r\n      /* Inport: '<Root>/SpindelPos' */\r\n      /*  Initialization of Variables and Outputs */\r\n      /* MATLAB Function 'MATLAB Function': '<S2>:1' */\r\n      /* '<S2>:1:5' DesSteps = uint16(0); */\r\n      /* '<S2>:1:6' Dir = uint16(0); */\r\n      /*  Declaration of constants */\r\n      /* '<S2>:1:9' MaxPos = 0x00FFFFFF; */\r\n      /* Point on which the encoder register will overflow  */\r\n      /*  Declaration of persistant variables */\r\n      /* '<S2>:1:19' if isempty(Carrier) */\r\n      /* '<S2>:1:23' if isempty(PrevSpindelpos) */\r\n      /* '<S2>:1:27' if isempty(ComCarrier) */\r\n      /* '<S2>:1:31' if isempty(ComCounter) */\r\n      /* '<S2>:1:35' if isempty(DIRCarrier) */\r\n      /* '<S2>:1:39' if (SpindelPos ~= PrevSpindelpos) && Enable */\r\n      if ((arg_SpindelPos != RealTimeMachine_DW.PrevSpindelpos) &&\r\n          (RealTimeMachine_B.Enable != 0U)) {\r\n        /*  Spindel in motion */\r\n        /*     %% Deal with encoder over/underflow and determine direction   */\r\n        /* '<S2>:1:42' ComCounter = uint16(0); */\r\n        /* '<S2>:1:44' if (SpindelPos > PrevSpindelpos) && ((SpindelPos - PrevSpindelpos) > (MaxPos/2)) */\r\n        SpindelDiv = arg_SpindelPos - /*MW:OvSatOk*/\r\n          RealTimeMachine_DW.PrevSpindelpos;\r\n        qY = SpindelDiv;\r\n        if (SpindelDiv > arg_SpindelPos) {\r\n          qY = 0UL;\r\n        }\r\n\r\n        if ((arg_SpindelPos > RealTimeMachine_DW.PrevSpindelpos) && (qY >\r\n             8388608UL)) {\r\n          /* '<S2>:1:45' SpindelDiv = (MaxPos - SpindelPos) + PrevSpindelpos; */\r\n          qY = 16777215UL - /*MW:OvSatOk*/ arg_SpindelPos;\r\n          if (16777215UL - arg_SpindelPos > 16777215UL) {\r\n            qY = 0UL;\r\n          }\r\n\r\n          SpindelDiv = qY + /*MW:OvSatOk*/ RealTimeMachine_DW.PrevSpindelpos;\r\n          if (SpindelDiv < qY) {\r\n            SpindelDiv = MAX_uint32_T;\r\n          }\r\n\r\n          /* '<S2>:1:46' PrevSpindelpos = SpindelPos; */\r\n          RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n          /* '<S2>:1:47' DIRCarrier = uint16(0); */\r\n          RealTimeMachine_DW.DIRCarrier = 0U;\r\n        } else {\r\n          qY_tmp = RealTimeMachine_DW.PrevSpindelpos - /*MW:OvSatOk*/\r\n            arg_SpindelPos;\r\n          qY = qY_tmp;\r\n          if (qY_tmp > RealTimeMachine_DW.PrevSpindelpos) {\r\n            qY = 0UL;\r\n          }\r\n\r\n          if ((arg_SpindelPos < RealTimeMachine_DW.PrevSpindelpos) && (qY >\r\n               8388608UL)) {\r\n            /* '<S2>:1:49' elseif(SpindelPos < PrevSpindelpos) && ((PrevSpindelpos - SpindelPos) > (MaxPos/2)) */\r\n            /* '<S2>:1:50' SpindelDiv = (MaxPos - PrevSpindelpos) + SpindelPos; */\r\n            qY = 16777215UL - /*MW:OvSatOk*/ RealTimeMachine_DW.PrevSpindelpos;\r\n            if (16777215UL - RealTimeMachine_DW.PrevSpindelpos > 16777215UL) {\r\n              qY = 0UL;\r\n            }\r\n\r\n            SpindelDiv = qY + /*MW:OvSatOk*/ arg_SpindelPos;\r\n            if (SpindelDiv < qY) {\r\n              SpindelDiv = MAX_uint32_T;\r\n            }\r\n\r\n            /* '<S2>:1:51' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:52' DIRCarrier = uint16(1); */\r\n            RealTimeMachine_DW.DIRCarrier = 1U;\r\n          } else if (arg_SpindelPos < RealTimeMachine_DW.PrevSpindelpos) {\r\n            /* '<S2>:1:54' elseif(SpindelPos < PrevSpindelpos) */\r\n            /* '<S2>:1:55' SpindelDiv = (PrevSpindelpos - SpindelPos); */\r\n            if (qY_tmp > RealTimeMachine_DW.PrevSpindelpos) {\r\n              qY_tmp = 0UL;\r\n            }\r\n\r\n            SpindelDiv = qY_tmp;\r\n\r\n            /* '<S2>:1:56' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:57' DIRCarrier = uint16(0); */\r\n            RealTimeMachine_DW.DIRCarrier = 0U;\r\n          } else if (arg_SpindelPos > RealTimeMachine_DW.PrevSpindelpos) {\r\n            /* '<S2>:1:59' elseif(SpindelPos > PrevSpindelpos) */\r\n            /* '<S2>:1:60' SpindelDiv = SpindelPos - PrevSpindelpos; */\r\n            if (SpindelDiv > arg_SpindelPos) {\r\n              SpindelDiv = 0UL;\r\n            }\r\n\r\n            /* '<S2>:1:61' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:62' DIRCarrier = uint16(1); */\r\n            RealTimeMachine_DW.DIRCarrier = 1U;\r\n          } else {\r\n            /* '<S2>:1:63' else */\r\n            /* '<S2>:1:64' SpindelDiv = uint32(0); */\r\n            SpindelDiv = 0UL;\r\n\r\n            /* '<S2>:1:65' DesSteps = uint16(0); */\r\n          }\r\n        }\r\n\r\n        /* Inport: '<Root>/CountFactor' */\r\n        /*     %% Calculate Desired Steps */\r\n        /* '<S2>:1:69' Carrier = Carrier + (Multiplier * double(SpindelDiv)); */\r\n        RealTimeMachine_DW.Carrier += arg_CountFactor * (real_T)SpindelDiv;\r\n\r\n        /* '<S2>:1:70' DesSteps = uint16(floor(Carrier)) */\r\n        DesSteps_tmp = floor(RealTimeMachine_DW.Carrier);\r\n        if (DesSteps_tmp < 65536.0) {\r\n          if (DesSteps_tmp >= 0.0) {\r\n            RealTimeMachine_B.DesSteps = (uint16_T)DesSteps_tmp;\r\n          } else {\r\n            RealTimeMachine_B.DesSteps = 0U;\r\n          }\r\n        } else {\r\n          RealTimeMachine_B.DesSteps = MAX_uint16_T;\r\n        }\r\n\r\n        /* '<S2>:1:71' Dir = DIRCarrier */\r\n        RealTimeMachine_B.Dir = RealTimeMachine_DW.DIRCarrier;\r\n\r\n        /* '<S2>:1:72' Carrier = Carrier - floor(Carrier); */\r\n        RealTimeMachine_DW.Carrier -= DesSteps_tmp;\r\n      } else {\r\n        /* '<S2>:1:74' else */\r\n        /* '<S2>:1:75' DesSteps = uint16(0) */\r\n        RealTimeMachine_B.DesSteps = 0U;\r\n\r\n        /* '<S2>:1:76' Dir = DIRCarrier */\r\n        RealTimeMachine_B.Dir = RealTimeMachine_DW.DIRCarrier;\r\n      }\r\n    }\r\n\r\n    if (((tmp & 128U) != 0U ? tmp | -128 : tmp & 127) == 1) {\r\n      /* Inport: '<Root>/SpindelPos' */\r\n      /*  Initialization of Variables and Outputs */\r\n      /* MATLAB Function 'MATLAB Function': '<S2>:1' */\r\n      /* '<S2>:1:5' DesSteps = uint16(0); */\r\n      /* '<S2>:1:6' Dir = uint16(0); */\r\n      /*  Declaration of constants */\r\n      /* '<S2>:1:9' MaxPos = 0x00FFFFFF; */\r\n      /* Point on which the encoder register will overflow  */\r\n      /*  Declaration of persistant variables */\r\n      /* '<S2>:1:19' if isempty(Carrier) */\r\n      /* '<S2>:1:23' if isempty(PrevSpindelpos) */\r\n      /* '<S2>:1:27' if isempty(ComCarrier) */\r\n      /* '<S2>:1:31' if isempty(ComCounter) */\r\n      /* '<S2>:1:35' if isempty(DIRCarrier) */\r\n      /* '<S2>:1:39' if (SpindelPos ~= PrevSpindelpos) && Enable */\r\n      if ((arg_SpindelPos != RealTimeMachine_DW.PrevSpindelpos) &&\r\n          (RealTimeMachine_B.Enable != 0U)) {\r\n        /*  Spindel in motion */\r\n        /*     %% Deal with encoder over/underflow and determine direction   */\r\n        /* '<S2>:1:42' ComCounter = uint16(0); */\r\n        /* '<S2>:1:44' if (SpindelPos > PrevSpindelpos) && ((SpindelPos - PrevSpindelpos) > (MaxPos/2)) */\r\n        qY = arg_SpindelPos - /*MW:OvSatOk*/ RealTimeMachine_DW.PrevSpindelpos;\r\n        if (qY > arg_SpindelPos) {\r\n          qY = 0UL;\r\n        }\r\n\r\n        if ((arg_SpindelPos > RealTimeMachine_DW.PrevSpindelpos) && (qY >\r\n             8388608UL)) {\r\n          /* '<S2>:1:45' SpindelDiv = (MaxPos - SpindelPos) + PrevSpindelpos; */\r\n          qY = 16777215UL - /*MW:OvSatOk*/ arg_SpindelPos;\r\n          if (16777215UL - arg_SpindelPos > 16777215UL) {\r\n            qY = 0UL;\r\n          }\r\n\r\n          SpindelDiv = qY + /*MW:OvSatOk*/ RealTimeMachine_DW.PrevSpindelpos;\r\n          if (SpindelDiv < qY) {\r\n            SpindelDiv = MAX_uint32_T;\r\n          }\r\n\r\n          /* '<S2>:1:46' PrevSpindelpos = SpindelPos; */\r\n          RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n          /* '<S2>:1:47' DIRCarrier = uint16(0); */\r\n          RealTimeMachine_DW.DIRCarrier = 0U;\r\n        } else {\r\n          SpindelDiv = RealTimeMachine_DW.PrevSpindelpos - /*MW:OvSatOk*/\r\n            arg_SpindelPos;\r\n          qY = SpindelDiv;\r\n          if (SpindelDiv > RealTimeMachine_DW.PrevSpindelpos) {\r\n            qY = 0UL;\r\n          }\r\n\r\n          if ((arg_SpindelPos < RealTimeMachine_DW.PrevSpindelpos) && (qY >\r\n               8388608UL)) {\r\n            /* '<S2>:1:49' elseif(SpindelPos < PrevSpindelpos) && ((PrevSpindelpos - SpindelPos) > (MaxPos/2)) */\r\n            /* '<S2>:1:50' SpindelDiv = (MaxPos - PrevSpindelpos) + SpindelPos; */\r\n            qY = 16777215UL - /*MW:OvSatOk*/ RealTimeMachine_DW.PrevSpindelpos;\r\n            if (16777215UL - RealTimeMachine_DW.PrevSpindelpos > 16777215UL) {\r\n              qY = 0UL;\r\n            }\r\n\r\n            SpindelDiv = qY + /*MW:OvSatOk*/ arg_SpindelPos;\r\n            if (SpindelDiv < qY) {\r\n              SpindelDiv = MAX_uint32_T;\r\n            }\r\n\r\n            /* '<S2>:1:51' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:52' DIRCarrier = uint16(1); */\r\n            RealTimeMachine_DW.DIRCarrier = 1U;\r\n          } else if (arg_SpindelPos < RealTimeMachine_DW.PrevSpindelpos) {\r\n            /* '<S2>:1:54' elseif(SpindelPos < PrevSpindelpos) */\r\n            /* '<S2>:1:55' SpindelDiv = (PrevSpindelpos - SpindelPos); */\r\n            if (SpindelDiv > RealTimeMachine_DW.PrevSpindelpos) {\r\n              SpindelDiv = 0UL;\r\n            }\r\n\r\n            /* '<S2>:1:56' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:57' DIRCarrier = uint16(0); */\r\n            RealTimeMachine_DW.DIRCarrier = 0U;\r\n          } else if (arg_SpindelPos > RealTimeMachine_DW.PrevSpindelpos) {\r\n            /* '<S2>:1:59' elseif(SpindelPos > PrevSpindelpos) */\r\n            /* '<S2>:1:60' SpindelDiv = SpindelPos - PrevSpindelpos; */\r\n            SpindelDiv = arg_SpindelPos - /*MW:OvSatOk*/\r\n              RealTimeMachine_DW.PrevSpindelpos;\r\n            if (SpindelDiv > arg_SpindelPos) {\r\n              SpindelDiv = 0UL;\r\n            }\r\n\r\n            /* '<S2>:1:61' PrevSpindelpos = SpindelPos; */\r\n            RealTimeMachine_DW.PrevSpindelpos = arg_SpindelPos;\r\n\r\n            /* '<S2>:1:62' DIRCarrier = uint16(1); */\r\n            RealTimeMachine_DW.DIRCarrier = 1U;\r\n          } else {\r\n            /* '<S2>:1:63' else */\r\n            /* '<S2>:1:64' SpindelDiv = uint32(0); */\r\n            SpindelDiv = 0UL;\r\n\r\n            /* '<S2>:1:65' DesSteps = uint16(0); */\r\n          }\r\n        }\r\n\r\n        /* Inport: '<Root>/CountFactor' */\r\n        /*     %% Calculate Desired Steps */\r\n        /* '<S2>:1:69' Carrier = Carrier + (Multiplier * double(SpindelDiv)); */\r\n        RealTimeMachine_DW.Carrier += arg_CountFactor * (real_T)SpindelDiv;\r\n\r\n        /* '<S2>:1:70' DesSteps = uint16(floor(Carrier)) */\r\n        DesSteps_tmp = floor(RealTimeMachine_DW.Carrier);\r\n        if (DesSteps_tmp < 65536.0) {\r\n          if (DesSteps_tmp >= 0.0) {\r\n            RealTimeMachine_B.DesSteps = (uint16_T)DesSteps_tmp;\r\n          } else {\r\n            RealTimeMachine_B.DesSteps = 0U;\r\n          }\r\n        } else {\r\n          RealTimeMachine_B.DesSteps = MAX_uint16_T;\r\n        }\r\n\r\n        /* '<S2>:1:71' Dir = DIRCarrier */\r\n        RealTimeMachine_B.Dir = RealTimeMachine_DW.DIRCarrier;\r\n\r\n        /* '<S2>:1:72' Carrier = Carrier - floor(Carrier); */\r\n        RealTimeMachine_DW.Carrier -= floor(RealTimeMachine_DW.Carrier);\r\n      } else {\r\n        /* '<S2>:1:74' else */\r\n        /* '<S2>:1:75' DesSteps = uint16(0) */\r\n        RealTimeMachine_B.DesSteps = 0U;\r\n\r\n        /* '<S2>:1:76' Dir = DIRCarrier */\r\n        RealTimeMachine_B.Dir = RealTimeMachine_DW.DIRCarrier;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Inport: '<Root>/System_Trigger' */\r\n  RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[0] = (ZCSigState)\r\n    (arg_System_Trigger[0] > 0U);\r\n  RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[1] = (ZCSigState)\r\n    (arg_System_Trigger[1] > 0U);\r\n\r\n  /* Outport: '<Root>/DesSteps' */\r\n  *arg_DesSteps = RealTimeMachine_B.DesSteps;\r\n\r\n  /* Outport: '<Root>/Dir' */\r\n  *arg_Dir = RealTimeMachine_B.Dir;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid RealTimeMachine_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &RealTimeMachine_B), 0,\r\n                sizeof(B_RealTimeMachine_T));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&RealTimeMachine_DW, 0,\r\n                sizeof(DW_RealTimeMachine_T));\r\n  RealTimeMachine_PrevZCX.Chart_Trig_ZCE[0] = UNINITIALIZED_ZCSIG;\r\n  RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[0] = UNINITIALIZED_ZCSIG;\r\n  RealTimeMachine_PrevZCX.Chart_Trig_ZCE[1] = UNINITIALIZED_ZCSIG;\r\n  RealTimeMachine_PrevZCX.MATLABFunction_Trig_ZCE[1] = UNINITIALIZED_ZCSIG;\r\n\r\n  /* SystemInitialize for Chart: '<Root>/Chart' */\r\n  RealTimeMachine_DW.is_MachineStatus = RealTimeMach_IN_NO_ACTIVE_CHILD;\r\n  RealTimeMachine_DW.is_active_c3_RealTimeMachine = 0U;\r\n  RealTimeMachine_DW.is_c3_RealTimeMachine = RealTimeMach_IN_NO_ACTIVE_CHILD;\r\n  RealTimeMachine_B.Enable = 0U;\r\n\r\n  /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function' */\r\n  /* '<S2>:1:20' Carrier = 0; */\r\n  RealTimeMachine_DW.Carrier = 0.0;\r\n\r\n  /* '<S2>:1:24' PrevSpindelpos = uint32(0); */\r\n  RealTimeMachine_DW.PrevSpindelpos = 0UL;\r\n\r\n  /* '<S2>:1:28' ComCarrier = uint16(0); */\r\n  /* '<S2>:1:32' ComCounter = uint16(0); */\r\n  /* '<S2>:1:36' DIRCarrier = uint16(0); */\r\n  RealTimeMachine_DW.DIRCarrier = 0U;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RealTimeMachine.h","type":"header","group":"model","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RealTimeMachine.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_RealTimeMachine_h_\r\n#define RTW_HEADER_RealTimeMachine_h_\r\n#include <math.h>\r\n#include <string.h>\r\n#ifndef RealTimeMachine_COMMON_INCLUDES_\r\n#define RealTimeMachine_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#endif                                 /* RealTimeMachine_COMMON_INCLUDES_ */\r\n\r\n#include \"RealTimeMachine_types.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\nvoid MW_InitSysPll(uint16_T clock_source, uint16_T imult, uint16_T fmult,\r\n                   uint16_T odiv, uint16_T divsel);\r\nextern void configureIXbar(void);\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  uint16_T DesSteps;                   /* '<Root>/MATLAB Function' */\r\n  uint16_T Dir;                        /* '<Root>/MATLAB Function' */\r\n  uint16_T Enable;                     /* '<Root>/Chart' */\r\n} B_RealTimeMachine_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T Carrier;                      /* '<Root>/MATLAB Function' */\r\n  uint32_T PrevSpindelpos;             /* '<Root>/MATLAB Function' */\r\n  uint16_T DIRCarrier;                 /* '<Root>/MATLAB Function' */\r\n  uint16_T is_active_c3_RealTimeMachine;/* '<Root>/Chart' */\r\n  uint16_T is_c3_RealTimeMachine;      /* '<Root>/Chart' */\r\n  uint16_T is_MachineStatus;           /* '<Root>/Chart' */\r\n} DW_RealTimeMachine_T;\r\n\r\n/* Zero-crossing (trigger) state */\r\ntypedef struct {\r\n  ZCSigState MATLABFunction_Trig_ZCE[2];/* '<Root>/MATLAB Function' */\r\n  ZCSigState Chart_Trig_ZCE[2];        /* '<Root>/Chart' */\r\n} PrevZCX_RealTimeMachine_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_RealTimeMachine_T_ {\r\n  uint16_T Constant_Value;             /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<Root>/Constant'\r\n                                        */\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_RealTimeMachine_T RealTimeMachine_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_RealTimeMachine_T RealTimeMachine_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_RealTimeMachine_T RealTimeMachine_DW;\r\n\r\n/* Zero-crossing (trigger) state */\r\nextern PrevZCX_RealTimeMachine_T RealTimeMachine_PrevZCX;\r\n\r\n/* Model entry point functions */\r\nextern void RealTimeMachine_initialize(void);\r\n\r\n/* Customized model step function */\r\nextern void RealTimeMachine_step(uint32_T arg_SpindelPos, real_T arg_CountFactor,\r\n  uint16_T arg_System_Trigger[2], uint16_T *arg_DesSteps, uint16_T *arg_Dir);\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'RealTimeMachine'\r\n * '<S1>'   : 'RealTimeMachine/Chart'\r\n * '<S2>'   : 'RealTimeMachine/MATLAB Function'\r\n */\r\n#endif                                 /* RTW_HEADER_RealTimeMachine_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RealTimeMachine_private.h","type":"header","group":"model","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RealTimeMachine_private.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_RealTimeMachine_private_h_\r\n#define RTW_HEADER_RealTimeMachine_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#endif                               /* RTW_HEADER_RealTimeMachine_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RealTimeMachine_types.h","type":"header","group":"model","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RealTimeMachine_types.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_RealTimeMachine_types_h_\r\n#define RTW_HEADER_RealTimeMachine_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\n/* Model Code Variants */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_RealTimeMachine_T_ P_RealTimeMachine_T;\r\n\r\n#endif                                 /* RTW_HEADER_RealTimeMachine_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"RealTimeMachine_data.c","type":"source","group":"data","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: RealTimeMachine_data.c\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"RealTimeMachine.h\"\r\n#include \"RealTimeMachine_private.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_RealTimeMachine_T RealTimeMachine_P = {\r\n  /* Computed Parameter: Constant_Value\r\n   * Referenced by: '<Root>/Constant'\r\n   */\r\n  0U\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Texas Instruments->C2000\r\n *   Number of bits:     char:  16    short:   16    int:  16\r\n *                       long:  32    long long:  64\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *                                                                       *\r\n *                                                                       *\r\n *   Note:  Because the specified hardware does not have native support  *\r\n *          for all data sizes, some data types are actually typedef'ed  *\r\n *          from larger native data sizes.  The following data types are *\r\n *          not in the ideal native data types:                          *\r\n *                                                                       *\r\n *          int8_T, uint8_T                                              *\r\n *=======================================================================*/\r\ntypedef int int8_T;\r\ntypedef unsigned int uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned int boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: zero_crossing_types.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/* Trigger directions: falling, either, and rising */\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\n/* Previous state of a trigger signal */\r\ntypedef uint8_T ZCSigState;\r\n\r\n/* Initial value of a trigger zero crossing signal */\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\n/* Current state of a trigger signal */\r\ntypedef enum {\r\n  FALLING_ZCEVENT = -1,\r\n  NO_ZCEVENT = 0,\r\n  RISING_ZCEVENT = 1\r\n} ZCEventType;\r\n\r\n#endif                                 /* ZERO_CROSSING_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'RealTimeMachine'.\r\n *\r\n * Model version                  : 3.11\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Wed Nov 24 16:34:53 2021\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Texas Instruments->C2000\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"RealTimeMachine.h\"\r\n#define MODEL_STEP_FCN_CONTROL_USED    1\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((void*) 0)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((void) 0)\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"MW_c28xGPIO.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGPIO.c\n * TITLE: GPIO functions to access the GPIO specific registers for C2000 target\n * Copyright 2017-2020 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n\n#include \"MW_c28xGPIO.h\"\n#ifdef CPU2\n#ifdef MW_F2837XD\n#include \"F2837xD_Ipc_drivers.h\"\n#define CPU01_TO_CPU02_PASSMSG  0x0003FFF4\n#endif //MW_F2837XD\n#ifdef MW_F2838X\n#include \"MW_f2838x_includes.h\"\n#endif //MW_F2838X\n#endif //CPU2\n\n/* ***************************************************************************/\n/* the defines */\n\n/* ***************************************************************************/\n/* the globals */\n\nUint16 GPIO_oneTimeInit = 0;\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* One time initialization of all GPIOs */\nvoid OneTimeGpioInit()\n{    \n    if(GPIO_oneTimeInit == 0)\n    {\n#ifdef CPU1\n        InitGpio();\n#endif //End of CPU1\n        GPIO_oneTimeInit = 1;\n    }\n}\n\n#ifndef MW_F281X /*GPIO implementation not supported for C281x */\n#ifndef F2837X_REG_FORMAT /*GPIO functions are provided by TI*/\n#ifndef MW_F2804X /*GPIO initialization is provided by TI for F2804x*/\n\n/*Sets all pins to be muxed to GPIO in input mode with pull-ups enabled.\n * Also sets the qualification to synchronous.*/\nvoid InitGpio()\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n    EALLOW;\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n            gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    /* For concerto additional registers needs to be initialized*/\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    /*Fill all registers with zeros. Writing to each register separately\n     * for all GPIO modules would make this function *very* long. Fortunately,\n     * we'd be writing them all with zeros anyway, so this saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioG1CtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioG1CtrlRegs)/2; regOffset++)\n    {\n        /*Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x10/2) != (0x0C/2))\n            gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    \n    gpioBaseAddr = (Uint32 *)&GpioG1DataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioG1DataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n    #endif //End of MW_PIL_TIC2000_CONCERTO\n    EDIS;\n}\n#endif // End of MW_F2804X\n\n/*Set the peripheral muxing for the specified pin.\n * The appropriate parameters can be found in the GPIO Muxed Pins table.\n * Use the GPIO index row (0 to 4) to select a muxing option for the GPIO.*/\nvoid GPIO_SetupPinMux(Uint16 pin, Uint16 cpu, Uint16 peripheral)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux;\n    Uint16 pin32, pin16;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Sanity check for valid peripheral values*/\n    if (peripheral > 0x4)\n        return;\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    \n    //Now for the actual function\n    EALLOW;\n    \n    /* Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some tricky\n     * bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *mux |= (Uint32)(peripheral & 0x3UL) << (2*pin16);\n    \n    //WARNING: This code does not touch the analog mode select registers,\n    //which are needed to give the USB module control of its IOs.\n    EDIS;\n}\n\n/*Setup up the GPIO input/output options for the specified pin.\n * The flags are a 16-bit mask produced by ORing together options.\n * For input pins, the valid flags are:\n * GPIO_PULLUP    Enable pull-up\n * GPIO_SYNC        Synchronize the input latch to PLLSYSCLK (default -- you don't need to specify this)\n * GPIO_QUAL3    Use 3-sample qualification\n * GPIO_QUAL6    Use 6-sample qualification\n * GPIO_ASYNC    Do not use synchronization or qualification\n * (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n * For output pins, the valid flags are:\n * GPIO_PULLUP        If open drain enabled, also enable the pull-up\n * and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n * With no flags, the default input state is synchronous with no pull-up or polarity inversion.\n * The default output state is the standard digital output.*/\nvoid GPIO_SetupPinOptions(Uint16 pin, Uint16 output, Uint16 flags)\n{\n    {\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n    \n    pin32 = pin % 32;\n    pin16 = pin % 16;\n    pinMask = 1UL << pin32;\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1080/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (0x80/2) + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (pin/32)*GPY_CTRL_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    \n    /*Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-2. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n    \n    EALLOW;\n    \n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {\n        /*Output, with optional open drain mode and pull-up*/\n        *dir |= pinMask;\n        \n        /*Enable pull-up if necessary. Open drain mode must be active.*/\n        if (flags & GPIO_PULLUP)\n            *pud &= ~pinMask;\n        else\n            *pud |= pinMask;\n    } else\n    {\n        /*Input, with optional pull-up, qualification, and polarity inversion*/\n        *dir &= ~pinMask;\n        \n        /*Enable pull-up if necessary*/\n        if (flags & GPIO_PULLUP)\n            *pud &= ~pinMask;\n        else\n            *pud |= pinMask;\n    }\n    \n    /*Extract the qualification parameter and load it into the register. This is\n     * also needed for open drain outputs, so we might as well do it all the time.*/\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n        *qsel |= qual << (2 * pin16);\n    \n    EDIS;\n    }\n}\n\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0)\n        gpioDataReg[GPYCLEAR] = pinMask;\n    else\n        gpioDataReg[GPYSET] = pinMask;\n}\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    #ifdef MW_PIL_TIC2000_CONCERTO\n    if (pin >= 128)\n    {\n        #ifdef F28M36x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x40/2);\n        }\n        else if (pin >=192 && pin <= 199)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x10C0/2);\n        }\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        if (pin <= 135)\n        {\n            gpioDataReg = (Uint32 *)&GpioDataRegs + (0x1000/2);\n        }\n        #endif //End of F28M35x_DEVICE_H\n    }\n    else\n    {\n        #ifdef F28M36x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (0xC0/2) + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M36x_DEVICE_H\n        #ifdef F28M35x_DEVICE_H\n        gpioDataReg = (Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n        #endif //End of F28M35x_DEVICE_H\n    }\n    #else\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    #endif // End of MW_PIL_TIC2000_CONCERTO\n    pinMask = 1UL << (pin % 32);\n    \n    \n    gpioDataReg[GPYTOGGLE] = pinMask;\n\n}\n\n#else // for F2837X_REG_FORMAT\n#if defined(MW_F2838X) \n#if defined(CPU1)\n\nvoid InitGpio()\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    /*Disable pin locks*/\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPCLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPDLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPELOCK.all = 0x00000000;\n    GpioCtrlRegs.GPFLOCK.all = 0x00000000;\n\n    /* Fill all registers with zeros. Writing to each register separately\n     * for six GPIO modules would make this function *very* long.\n     * Fortunately, we'd be writing them all with zeros anyway, so this\n     * saves a lot of space.*/\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        /* Hack to avoid enabling pull-ups on all pins. GPyPUD is offset\n         * 0x0C in each register group of 0x40 words. Since this is a\n         * 32-bit pointer, the addresses must be divided by 2.*/\n        if (regOffset % (0x40/2) != (0x0C/2))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000;\n        }\n    }\n\n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n\n    EDIS;\n}\n\nvoid GPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /*Sanity check for valid cpu and peripheral values*/\n    if (cpu > GPIO_MUX_CM || muxPosition > 0xF)\n        return;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyCSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    /* Now for the actual function */\n    EALLOW;\n\n    /* To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n     * glitches, then change the group mux, then set the peripheral mux to\n     * its target value. Finally, set the CPU select. This procedure is\n     * described in the TRM. Unfortunately, since we don't know the pin in\n     * advance we can't hardcode a bitfield reference, so there's some\n     * tricky bit twiddling here.*/\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n    *csel &= ~(0x7L << (4*pin8));\n    *csel |= (Uint32)(cpu & 0x7L) << (4*pin8);\n\n    /* WARNING: This code does not touch the analog mode select registers,\n     * which are needed to give the USB module control of its IOs.*/\n    EDIS;\n}\n\nvoid GPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    /* Create pointers to the appropriate registers. This is a workaround\n     * for the way GPIO registers are defined. The standard definition\n     * in the header file makes it very easy to do named accesses of one\n     * register or bit, but hard to do arbitrary numerical accesses. It's\n     * easier to have an array of GPIO modules with identical registers,\n     * including arrays for multi-register groups like GPyQSEL1-4. But\n     * the header file doesn't define anything we can turn into an array,\n     * so manual pointer arithmetic is used instead.*/\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    /*Set the data direction*/\n    *dir &= ~pinMask;\n    if (output == 1)\n    {        \n        /* Output, with optional open drain mode and pull-up */        \n        *dir |= pinMask;\n\n        /* Enable open drain if necessary */\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        /* Enable pull-up if necessary. Open drain mode must be active. */\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n    else\n    {\n        /* Input, with optional pull-up, qualification, and polarity\n         * inversion */\n        *dir &= ~pinMask;\n\n        /* Enable pull-up if necessary */\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        /* Invert polarity if necessary */\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    /* Extract the qualification parameter and load it into the register.\n     * This is also needed for open drain outputs, so we might as well do it\n     * all the time. */\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor176Pin()\n{\n\tEALLOW;\n\tGpioCtrlRegs.GPCPUD.all = ~0x80000000;  /* GPIO 95 */\n\tGpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  /* GPIOs 96-127 */\n\tGpioCtrlRegs.GPEPUD.all = ~0xFFFFFFDF;  /* GPIOs 128-159 except for 133 */\n\tGpioCtrlRegs.GPFPUD.all = ~0x000001FF;  /* GPIOs 160-168 */\n\tEDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullupsFor100Pin()\n{\n    EALLOW;\n    GpioCtrlRegs.GPAPUD.all = ~0xFFC003E3;  //GPIOs 0-1, 5-9, 22-31\n    GpioCtrlRegs.GPBPUD.all = ~0x03FFF1FF;  //GPIOs 32-40, 44-57\n    GpioCtrlRegs.GPCPUD.all = ~0xE10FBC18;  //GPIOs 67-68, 74-77, 79-83, 93-95\n    GpioCtrlRegs.GPDPUD.all = ~0xFFFFFFF7;  //GPIOs 96-127\n    GpioCtrlRegs.GPEPUD.all = ~0xFFFFFFFF;  //GPIOs 128-159\n    GpioCtrlRegs.GPFPUD.all = ~0x000001FF;  //GPIOs 160-168\n    EDIS;\n}\n\nvoid GPIO_EnableUnbondedIOPullups()\n{\n\t/* bits 8-10 have pin count */\n    unsigned char pin_count = ((DevCfgRegs.PARTIDL.all & 0x00000700) >> 8) ;\n\n\t/* 5 = 100 pin\n\t * 6 = 176 pin\n\t * 7 = 337 pin */\n    if(pin_count == 5)\n    {\n        GPIO_EnableUnbondedIOPullupsFor100Pin();\n    }\n    else if (pin_count == 6)\n\t{\n\t\tGPIO_EnableUnbondedIOPullupsFor176Pin();\n\t}\n\telse\n\t{\n\t\t/* do nothing - this is 337 pin package */\n\t}\n}\n#endif // defined(CPU1)\n/*Read the GPyDAT register bit for the specified pin.\n * Note that this returns the actual state of the pin, not the state of the output latch.*/\nUint16 GPIO_ReadPin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (pin % 32)) & 0x1;\n    \n    return pinVal;\n}\n\n/*Set the GPyDAT register bit for the specified pin.*/\nvoid GPIO_WritePin(Uint16 pin, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    \n    if (outVal == 0)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n#endif // end of defined(MW_F2838X)\n\n/*Toggle the GPyDAT register bit for the specified pin.*/\nvoid GPIO_TogglePin(Uint16 pin)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n    \n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (pin/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (pin % 32);\n    gpioDataReg[GPYTOGGLE] = pinMask;\n}\n#endif // end of F2837X_REG_FORMAT\n\n/*Set the GPIO pin. Set the mux values and pin options for the specified pin.\n  This function can be used for all processors except C281x. The implementation is dependant on CPU1 and CPU2*/ \nvoid Set_GPIOPin(Uint16 pin, Uint16 cpu, Uint16 peripheral, Uint16 output, Uint16 flags)\n{\n#if defined(F2837X_REG_FORMAT) && defined(CPU2)\n    Uint32 *pulMsgRam = (void *)CPU01_TO_CPU02_PASSMSG;\n    Uint32 gpioData = 0x00000000;\n    //Sanity check for valid cpu and peripheral values\n    if (cpu > GPIO_MUX_CPU2CLA || peripheral > 0xF)\n        return;\n    gpioData = gpioData | pin;\n    gpioData = gpioData | ((Uint32)peripheral << 8);\n    gpioData = gpioData | ((Uint32)output << 16);\n    gpioData = gpioData | ((Uint32)flags << 24);\n    #ifdef MW_F2837XD\n    Uint32 ulRWord32 = 0;\n    IPCLiteLtoRFunctionCall(IPC_FLAG0, pulMsgRam[0], gpioData, IPC_FLAG31);\n    while (IPCLiteLtoRGetResult(&ulRWord32,IPC_LENGTH_32_BITS,\n            IPC_FLAG31) != STATUS_PASS)\n    {\n    }\n    #else\n     MW_IPC_sendCommand(IPC_CPU2_L_CPU1_R, (IPC_FLAG0 | IPC_FLAG31), IPC_ADDR_CORRECTION_DISABLE, IPC_FUNC_CALL, pulMsgRam[0], gpioData);\n    IPC_waitForAck(IPC_CPU2_L_CPU1_R, IPC_FLAG31);\n    IPC_getResponse(IPC_CPU2_L_CPU1_R);\n    #endif //MW_F2837XD\n#else\n    GPIO_SetupPinMux(pin, cpu, peripheral);\n    GPIO_SetupPinOptions(pin, output, flags);\n#endif // end of defined(F2837X_REG_FORMAT) && defined(CPU2)\n}\n#endif //end of MW_F281X\n    \n"},{"name":"MW_c28xGlobalInterrupts.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\shared\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/*####################################################\n * FILE: MW_c28xGlobalInterrupts.c\n * TITLE: Common board support functions specific for C2000 targets\n * Copyright 2020 The MathWorks, Inc.\n * ####################################################*/\n\n/* ***************************************************************************/\n/* the includes */\n#include \"MW_target_hardware_resources.h\"\n\n/* ***************************************************************************/\n/* the globals */\nUint16 MW_InterruptDisableLock;\n\n\n/* ***************************************************************************/\n/* the functions*/\n\n/* Global interrupt enable function */\nvoid globalInterruptEnable(void)\n{\n    if (0 == MW_InterruptDisableLock)\n    {\n        /* Enabled the interrupts only if it was enabled before */\n        __enable_interrupts(); /* Enable Global Interrupt INTM and realtime interrupt DBGM */\n    }\n}\n\n/* Global interrupt disable function */\nvoid globalInterruptDisable(void)\n{\n    /* Disable Global Interrupt INTM using __disable_interrupts()\n     The function will return 0 if interrupt was enabled previously\n     otherwise it will return 1 if the interrupt was previously disabled*/\n    MW_InterruptDisableLock = __disable_interrupts();\n    MW_InterruptDisableLock &= 0x1;   \n}\n"},{"name":"MW_c28xx_board.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f28004x_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"RealTimeMachine.h\"\r\n#include \"RealTimeMachine_private.h\"\r\n\r\nvoid init_board ()\r\n{\r\n  DisableDog();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.DMA = 1;\r\n  CpuSysRegs.PCLKCR6.bit.SD1 = 1;\r\n  CpuSysRegs.PCLKCR17.bit.CLB1 = 1;\r\n  CpuSysRegs.PCLKCR17.bit.CLB2 = 1;\r\n  CpuSysRegs.PCLKCR17.bit.CLB3 = 1;\r\n  CpuSysRegs.PCLKCR17.bit.CLB4 = 1;\r\n  EDIS;\r\n\r\n#ifdef CPU1\r\n\r\n  EALLOW;\r\n  EDIS;\r\n  MW_InitSysPll(XTAL_OSC,10,0,0,1);\r\n\r\n  //Turn on all peripherals\r\n  //InitPeripheralClocks();\r\n  EALLOW;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;\r\n  CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;\r\n  CpuSysRegs.PCLKCR0.bit.HRPWM = 1;\r\n  EDIS;\r\n\r\n#endif\r\n\r\n  EALLOW;\r\n\r\n  /* Configure low speed peripheral clocks */\r\n  ClkCfgRegs.LOSPCP.bit.LSPCLKDIV = 0U;\r\n  EDIS;\r\n\r\n  /* Disable and clear all CPU interrupts */\r\n  DINT;\r\n  IER = 0x0000;\r\n  IFR = 0x0000;\r\n  InitPieCtrl();\r\n  InitPieVectTable();\r\n  InitCpuTimers();\r\n  configureIXbar();\r\n\r\n  /* initial GPIO qualification settings.... */\r\n  EALLOW;\r\n  GpioCtrlRegs.GPAQSEL1.all = 0x0;\r\n  GpioCtrlRegs.GPAQSEL2.all = 0x0;\r\n  GpioCtrlRegs.GPBQSEL1.all = 0x0;\r\n  GpioCtrlRegs.GPBQSEL2.all = 0x0;\r\n\r\n  // Set the pin to digital mode by default\r\n  GpioCtrlRegs.GPAAMSEL.bit.GPIO22 = 0;\r\n  GpioCtrlRegs.GPAAMSEL.bit.GPIO23 = 0;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_c28xx_csl.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f28004x_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"RealTimeMachine.h\"\r\n#include \"RealTimeMachine_private.h\"\r\n\r\nvoid enableExtInterrupt (void);\r\nvoid disableWatchdog(void)\r\n{\r\n  int *WatchdogWDCR = (void *) 0x7029;\r\n  asm(\" EALLOW \");\r\n  *WatchdogWDCR = 0x0068;\r\n  asm(\" EDIS \");\r\n}\r\n"},{"name":"MW_c28xx_pie.h","type":"header","group":"other","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#define PIEMASK0                       64\r\n#define IFRMASK                        1\r\n"},{"name":"MW_c28xx_xbar.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"c2000BoardSupport.h\"\r\n#include \"MW_f28004x_includes.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"RealTimeMachine.h\"\r\n#include \"RealTimeMachine_private.h\"\r\n#include \"MW_c28xGPIO.h\"\r\n\r\nvoid configureIXbar(void)\r\n{\r\n  /*--- Configuring GPIO set in Input Xbar---*/\r\n  EALLOW;\r\n  InputXbarRegs.INPUT7SELECT = 35;\r\n  InputXbarRegs.INPUT8SELECT = 37;\r\n  InputXbarRegs.INPUT9SELECT = 59;\r\n  InputXbarRegs.INPUT10SELECT = 14;\r\n  InputXbarRegs.INPUT11SELECT = 15;\r\n  InputXbarRegs.INPUT12SELECT = 26;\r\n  InputXbarRegs.INPUT13SELECT = 58;\r\n  EDIS;\r\n}\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"c2000BoardSupport.h\"\n#include \"MW_f28004x_includes.h\"\n#include \"c2000SchedulerTimer.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE TI Piccolo F28004x\n#define MW_CONNECTIONINFO_SERIAL_IPADDRESS codertarget.registry.getLoopbackIP;\n#define MW_CONNECTIONINFO_SERIAL_PORT 17725\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.registry.getExtModeHostBaud(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.registry.serialPortValueCallback(hCS, 'ExtModeCOMPort');\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_CONNECTIONINFO_CAN_MEXARGS  \n#define MW_CONNECTIONINFO_XCPONCAN_MEXARGS  \n#define MW_CONNECTIONINFO_XCPONCAN_BUSSPEED codertarget.registry.getExtModeCANBusSpeed(hCS)\n#define MW_CONNECTIONINFO_XCPONCAN_CANCHANNEL \n#define MW_CONNECTIONINFO_XCPONCAN_CANDEVICE \n#define MW_CONNECTIONINFO_XCPONCAN_CANIDCOMMAND 2\n#define MW_CONNECTIONINFO_XCPONCAN_CANIDRESPONSE 3\n#define MW_CONNECTIONINFO_XCPONCAN_CANVENDOR \n#define MW_CONNECTIONINFO_XCPONCAN_ISCANIDEXTENDED 0\n#define MW_CONNECTIONINFO_XCPONCAN_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION serial\n#define MW_EXTMODE_HOSTINTERFACE Simulink\n#define MW_EXTMODE_CANMODULE 0\n#define MW_EXTMODE_CANIDTYPE Standard (11-bit)\n#define MW_EXTMODE_CANMASTERID 0x02\n#define MW_EXTMODE_CANSLAVEID 0x03\n#define MW_EXTMODE_CANRXMAILBOXNUMBER 0\n#define MW_EXTMODE_CANTXMAILBOXNUMBER 1\n#define MW_EXTMODE_SCIMODULE 0\n#define MW_EXTMODE_SIGNALBUFFERSIZE 5000.000000\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_DEVICEID 1\n#define MW_RUNTIME_FLASHLOAD 1\n#define MW_RUNTIME_ENABLETMU 1\n#define MW_RUNTIME_LOADCOMMANDARG $(TARGET_ROOT)/CCS_Config/f280049M.ccxml\n#define MW_TARGETLINKOBJ_USECUSTOMLINKER 0\n#define MW_TARGETLINKOBJ_NAME $(TARGET_ROOT)/src/c280049M.cmd\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 100\n#define MW_CLOCKING_USEINTERNALOSC 0\n#define MW_CLOCKING_OSCCLK 20\n#define MW_CLOCKING_AUTOSETPLLSETTINGS 1\n#define MW_CLOCKING_PLLCR 10\n#define MW_CLOCKING_PLLDIV 0\n#define MW_CLOCKING_DIVSEL 2\n#define MW_CLOCKING_CLOSESTCPUCLOCK 100\n#define MW_CLOCKING_LSPCLKDIV 0\n#define MW_CLOCKING_LSPCLK 100\n#define MW_IXBAR_FLAG 49\n#define MW_IXBAR_I1 None\n#define MW_IXBAR_I2 None\n#define MW_IXBAR_I3 None\n#define MW_IXBAR_I4 None\n#define MW_IXBAR_I5 None\n#define MW_IXBAR_I6 None\n#define MW_IXBAR_I7 35\n#define MW_IXBAR_I8 37\n#define MW_IXBAR_I9 59\n#define MW_IXBAR_I10 14\n#define MW_IXBAR_I11 15\n#define MW_IXBAR_I12 26\n#define MW_IXBAR_I13 58\n#define MW_IXBAR_I14 None\n#define MW_IXBAR_I15 None\n#define MW_IXBAR_I16 None\n#define MW_IXBAR_ONE_TIME 0.000000\n#define MW_OUTPUTXBAR_OXBAR1 0\n#define MW_OUTPUTXBAR_OXBAR_MUX1 -1\n#define MW_OUTPUTXBAR_OXBAR1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR1_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR1_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR1_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR2 0\n#define MW_OUTPUTXBAR_OXBAR_MUX2 -1\n#define MW_OUTPUTXBAR_OXBAR2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR2_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR2_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR2_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR3 0\n#define MW_OUTPUTXBAR_OXBAR_MUX3 -1\n#define MW_OUTPUTXBAR_OXBAR3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR3_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR3_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR3_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR4 0\n#define MW_OUTPUTXBAR_OXBAR_MUX4 -1\n#define MW_OUTPUTXBAR_OXBAR4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR4_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR4_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR4_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR5 0\n#define MW_OUTPUTXBAR_OXBAR_MUX5 -1\n#define MW_OUTPUTXBAR_OXBAR5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR5_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR5_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR5_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR6 0\n#define MW_OUTPUTXBAR_OXBAR_MUX6 -1\n#define MW_OUTPUTXBAR_OXBAR6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR6_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR6_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR6_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR7 0\n#define MW_OUTPUTXBAR_OXBAR_MUX7 -1\n#define MW_OUTPUTXBAR_OXBAR7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR7_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR7_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR7_INVERT 0\n#define MW_OUTPUTXBAR_OXBAR8 0\n#define MW_OUTPUTXBAR_OXBAR_MUX8 -1\n#define MW_OUTPUTXBAR_OXBAR8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_OUTPUTXBAR_OXBAR8_GPIO 0\n#define MW_OUTPUTXBAR_OXBAR8_LATCH 0\n#define MW_OUTPUTXBAR_OXBAR8_INVERT 0\n#define MW_ADCA_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCA_EXTERNALREFERENCEVREFHI 0\n#define MW_ADCA_CLOCKDIV 1\n#define MW_ADCA_CLOCKFREQUENCY 50.000000\n#define MW_ADCA_OFFSETCORRECTIONVALUE AdcaRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCA_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCA_INTPULSEGENERATION 0\n#define MW_ADCA_SOCPRIORITY 0\n#define MW_ADCA_XINT2GPIO_IXBAR 0\n#define MW_ADCA_XINT2GPIO None\n#define MW_ADCB_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCB_EXTERNALREFERENCEVREFHI 0\n#define MW_ADCB_CLOCKDIV 1\n#define MW_ADCB_CLOCKFREQUENCY 50.000000\n#define MW_ADCB_OFFSETCORRECTIONVALUE AdcbRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCB_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCB_INTPULSEGENERATION 0\n#define MW_ADCB_SOCPRIORITY 0\n#define MW_ADCB_XINT2GPIO_IXBAR 0\n#define MW_ADCB_XINT2GPIO None\n#define MW_ADCC_EXTERNALREFERENCESELECTOR 0\n#define MW_ADCC_EXTERNALREFERENCEVREFHI 0\n#define MW_ADCC_CLOCKDIV 1\n#define MW_ADCC_CLOCKFREQUENCY 50.000000\n#define MW_ADCC_OFFSETCORRECTIONVALUE AdccRegs.ADCOFFTRIM.bit.OFFTRIM\n#define MW_ADCC_EXTERNALREFERENCEVREFLO 0\n#define MW_ADCC_INTPULSEGENERATION 0\n#define MW_ADCC_SOCPRIORITY 0\n#define MW_ADCC_XINT2GPIO_IXBAR 0\n#define MW_ADCC_XINT2GPIO None\n#define MW_DACA_VOLTAGE 0\n#define MW_DACA_LOADMODE 0\n#define MW_DACB_VOLTAGE 0\n#define MW_DACB_LOADMODE 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS1 0\n#define MW_CMPSS_CMPSS1_COMPH 0\n#define MW_CMPSS_CMPSS1_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS1_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS1_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS1_COMPL 0\n#define MW_CMPSS_CMPSS1_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS1_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS1_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS1_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS1_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS1_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS1_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS1_COMP_SELREF 0\n#define MW_CMPSS_CMPSS1_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS1_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS1_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS1_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS2 0\n#define MW_CMPSS_CMPSS2_COMPH 0\n#define MW_CMPSS_CMPSS2_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS2_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS2_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS2_COMPL 0\n#define MW_CMPSS_CMPSS2_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS2_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS2_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS2_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS2_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS2_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS2_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS2_COMP_SELREF 0\n#define MW_CMPSS_CMPSS2_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS2_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS2_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS2_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS3 0\n#define MW_CMPSS_CMPSS3_COMPH 0\n#define MW_CMPSS_CMPSS3_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS3_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS3_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS3_COMPL 0\n#define MW_CMPSS_CMPSS3_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS3_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS3_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS3_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS3_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS3_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS3_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS3_COMP_SELREF 0\n#define MW_CMPSS_CMPSS3_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS3_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS3_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS3_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS4 0\n#define MW_CMPSS_CMPSS4_COMPH 0\n#define MW_CMPSS_CMPSS4_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS4_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS4_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS4_COMPL 0\n#define MW_CMPSS_CMPSS4_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS4_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS4_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS4_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS4_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS4_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS4_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS4_COMP_SELREF 0\n#define MW_CMPSS_CMPSS4_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS4_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS4_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS4_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS5 0\n#define MW_CMPSS_CMPSS5_COMPH 0\n#define MW_CMPSS_CMPSS5_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS5_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS5_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS5_COMPL 0\n#define MW_CMPSS_CMPSS5_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS5_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS5_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS5_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS5_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS5_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS5_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS5_COMP_SELREF 0\n#define MW_CMPSS_CMPSS5_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS5_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS5_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS5_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS6 0\n#define MW_CMPSS_CMPSS6_COMPH 0\n#define MW_CMPSS_CMPSS6_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS6_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS6_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS6_COMPL 0\n#define MW_CMPSS_CMPSS6_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS6_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS6_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS6_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS6_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS6_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS6_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS6_COMP_SELREF 0\n#define MW_CMPSS_CMPSS6_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS6_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS6_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS6_COMP_COMPHYS 0\n#define MW_CMPSS_ENABLE_MODULE_CMPSS7 0\n#define MW_CMPSS_CMPSS7_COMPH 0\n#define MW_CMPSS_CMPSS7_COMPH_RAMPLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMPH_COMPHINV 0\n#define MW_CMPSS_CMPSS7_COMPH_HSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPH_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPH_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPH_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPH_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPH 0\n#define MW_CMPSS_CMPSS7_COMPH_CTRIPOUTH 0\n#define MW_CMPSS_CMPSS7_COMPL 0\n#define MW_CMPSS_CMPSS7_COMPL_COMPLINV 0\n#define MW_CMPSS_CMPSS7_COMPL_LSYNCCLREN 0\n#define MW_CMPSS_CMPSS7_COMPL_DIGITALFILTER 0\n#define MW_CMPSS_CMPSS7_COMPL_CLKPRESCALE 0\n#define MW_CMPSS_CMPSS7_COMPL_SAMPWIN 0\n#define MW_CMPSS_CMPSS7_COMPL_THRESH 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPL 0\n#define MW_CMPSS_CMPSS7_COMPL_CTRIPOUTL 0\n#define MW_CMPSS_CMPSS7_COMP_SELREF 0\n#define MW_CMPSS_CMPSS7_COMP_SWLOADSEL 0\n#define MW_CMPSS_CMPSS7_COMP_RAMPSOURCE 0\n#define MW_CMPSS_CMPSS7_COMP_BLANKSOURCE 0\n#define MW_CMPSS_CMPSS7_COMP_COMPHYS 0\n#define MW_EPWM_CLOCKDIV 0\n#define MW_EPWM_PINASSIGNMENT_TZ1_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ2_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ3_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_TZ1 None\n#define MW_EPWM_PINASSIGNMENT_TZ2 None\n#define MW_EPWM_PINASSIGNMENT_TZ3 None\n#define MW_EPWM_EXBAR_TRIP4 0\n#define MW_EPWM_EXBAR_MUX_TRIP4 -1\n#define MW_EPWM_EXBAR_TRIP4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP4_INVERT 0\n#define MW_EPWM_EXBAR_TRIP5 0\n#define MW_EPWM_EXBAR_MUX_TRIP5 -1\n#define MW_EPWM_EXBAR_TRIP5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP5_INVERT 0\n#define MW_EPWM_EXBAR_TRIP7 0\n#define MW_EPWM_EXBAR_MUX_TRIP7 -1\n#define MW_EPWM_EXBAR_TRIP7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP7_INVERT 0\n#define MW_EPWM_EXBAR_TRIP8 0\n#define MW_EPWM_EXBAR_MUX_TRIP8 -1\n#define MW_EPWM_EXBAR_TRIP8_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP8_INVERT 0\n#define MW_EPWM_EXBAR_TRIP9 0\n#define MW_EPWM_EXBAR_MUX_TRIP9 -1\n#define MW_EPWM_EXBAR_TRIP9_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP9_INVERT 0\n#define MW_EPWM_EXBAR_TRIP10 0\n#define MW_EPWM_EXBAR_MUX_TRIP10 -1\n#define MW_EPWM_EXBAR_TRIP10_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP10_INVERT 0\n#define MW_EPWM_EXBAR_TRIP11 0\n#define MW_EPWM_EXBAR_MUX_TRIP11 -1\n#define MW_EPWM_EXBAR_TRIP11_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP11_INVERT 0\n#define MW_EPWM_EXBAR_TRIP12 0\n#define MW_EPWM_EXBAR_MUX_TRIP12 -1\n#define MW_EPWM_EXBAR_TRIP12_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_EPWM_EXBAR_TRIP12_INVERT 0\n#define MW_EPWM_PINASSIGNMENT_SYNCI_IXBAR 0\n#define MW_EPWM_PINASSIGNMENT_SYNCI None\n#define MW_EPWM_PINASSIGNMENT_SYNCO None\n#define MW_EPWM_PINASSIGNMENT_PWM1A 1\n#define MW_EPWM_PINASSIGNMENT_PWM1B 1\n#define MW_EPWM_PINASSIGNMENT_PWM2A 1\n#define MW_EPWM_PINASSIGNMENT_PWM2B 1\n#define MW_EPWM_PINASSIGNMENT_PWM3A 1\n#define MW_EPWM_PINASSIGNMENT_PWM3B 1\n#define MW_EPWM_PINASSIGNMENT_PWM4A 1\n#define MW_EPWM_PINASSIGNMENT_PWM4B 1\n#define MW_EPWM_PINASSIGNMENT_PWM5A 1\n#define MW_EPWM_PINASSIGNMENT_PWM5B 1\n#define MW_EPWM_PINASSIGNMENT_PWM6A 1\n#define MW_EPWM_PINASSIGNMENT_PWM6B 1\n#define MW_EPWM_PINASSIGNMENT_PWM7A 1\n#define MW_EPWM_PINASSIGNMENT_PWM7B 1\n#define MW_EPWM_PINASSIGNMENT_PWM8A 1\n#define MW_EPWM_PINASSIGNMENT_PWM8B 2\n#define MW_ECAP_PINASSIGNMENT_ECAP1_IXBAR 6\n#define MW_ECAP_PINASSIGNMENT_ECAP2_IXBAR 7\n#define MW_ECAP_PINASSIGNMENT_ECAP3_IXBAR 8\n#define MW_ECAP_PINASSIGNMENT_ECAP4_IXBAR 9\n#define MW_ECAP_PINASSIGNMENT_ECAP5_IXBAR 10\n#define MW_ECAP_PINASSIGNMENT_ECAP6_IXBAR 11\n#define MW_ECAP_PINASSIGNMENT_ECAP7_IXBAR 12\n#define MW_ECAP_PINASSIGNMENT_ECAP1 GPIO35\n#define MW_ECAP_PINASSIGNMENT_ECAP2 GPIO37\n#define MW_ECAP_PINASSIGNMENT_ECAP3 GPIO59\n#define MW_ECAP_PINASSIGNMENT_ECAP4 GPIO14\n#define MW_ECAP_PINASSIGNMENT_ECAP5 GPIO15\n#define MW_ECAP_PINASSIGNMENT_ECAP6 GPIO26\n#define MW_ECAP_PINASSIGNMENT_ECAP7 GPIO58\n#define MW_ECAP_PINASSIGNMENT_APWM1 13\n#define MW_ECAP_PINASSIGNMENT_APWM2 23\n#define MW_ECAP_PINASSIGNMENT_APWM3 25\n#define MW_ECAP_PINASSIGNMENT_APWM4 9\n#define MW_ECAP_PINASSIGNMENT_APWM5 10\n#define MW_ECAP_PINASSIGNMENT_APWM6 15\n#define MW_ECAP_PINASSIGNMENT_APWM7 24\n#define MW_ECAP_PINASSIGNMENT_APWM1_OXBAR 1.000000\n#define MW_ECAP_PINASSIGNMENT_APWM2_OXBAR 2.000000\n#define MW_ECAP_PINASSIGNMENT_APWM3_OXBAR 2.000000\n#define MW_ECAP_PINASSIGNMENT_APWM4_OXBAR 3.000000\n#define MW_ECAP_PINASSIGNMENT_APWM5_OXBAR 4.000000\n#define MW_ECAP_PINASSIGNMENT_APWM6_OXBAR 3.000000\n#define MW_ECAP_PINASSIGNMENT_APWM7_OXBAR 1.000000\n#define MW_EQEP_PINASSIGNMENT_EQEP1A 5\n#define MW_EQEP_PINASSIGNMENT_EQEP1B 5\n#define MW_EQEP_PINASSIGNMENT_EQEP1S 4\n#define MW_EQEP_PINASSIGNMENT_EQEP1I 4\n#define MW_EQEP_PINASSIGNMENT_EQEP2A 3\n#define MW_EQEP_PINASSIGNMENT_EQEP2B 2\n#define MW_EQEP_PINASSIGNMENT_EQEP2S 1\n#define MW_EQEP_PINASSIGNMENT_EQEP2I 1\n#define MW_I2C_MODE 0\n#define MW_I2C_ADDRDATAFORMAT 0\n#define MW_I2C_OWNADDRESS 1\n#define MW_I2C_BITCOUNT 0\n#define MW_I2C_MODULECLOCKPRESCALER 9\n#define MW_I2C_MODULECLOCKFREQUENCY 10000000.000000\n#define MW_I2C_MASTERCLKLOWTIME 10\n#define MW_I2C_MASTERCLKHIGHTIME 10\n#define MW_I2C_MASTERCLOCKFREQUENCY 333333.333333\n#define MW_I2C_MASTERCLOCKFREQUENCY_1 333333.333333\n#define MW_I2C_MASTERCLOCKFREQUENCY_2 333333.333333\n#define MW_I2C_ENABLELOOPBACK 0\n#define MW_I2C_PINASSIGNMENT_SDAA 3\n#define MW_I2C_PINASSIGNMENT_SCLA 4\n#define MW_I2C_ENABLETXINT 0\n#define MW_I2C_TXFIFOLEVEL 16\n#define MW_I2C_ENABLERXINT 0\n#define MW_I2C_RXFIFOLEVEL 16\n#define MW_I2C_ENABLESYSINT 0\n#define MW_I2C_AAS 0\n#define MW_I2C_SCD 0\n#define MW_I2C_ARDY 0\n#define MW_I2C_NACK 0\n#define MW_I2C_AL 0\n#define MW_I2C_PINVALUE_SDA 32\n#define MW_I2C_PINVALUE_SCL 33\n#define MW_I2C_PINMUX_SDA 1\n#define MW_I2C_PINMUX_SCL 1\n#define MW_SCI_A_ENABLELOOPBACK 0\n#define MW_SCI_A_SUSPENSIONMODE 2\n#define MW_SCI_A_NUMBEROFSTOPBITS 0\n#define MW_SCI_A_PARITYMODE 0\n#define MW_SCI_A_CHARACTERLENGTHBITS 0\n#define MW_SCI_A_USERBAUDRATE 115200\n#define MW_SCI_A_BAUDRATEPRESCALER 108.000000\n#define MW_SCI_A_BAUDRATE 114679.000000\n#define MW_SCI_A_COMMUNICATIONMODE 0\n#define MW_SCI_A_BLOCKINGMODE 0\n#define MW_SCI_A_DATABYTEORDER 0\n#define MW_SCI_A_DATASWAPWIDTH 0\n#define MW_SCI_A_PINASSIGNMENT_TX 5\n#define MW_SCI_A_PINASSIGNMENT_RX 5\n#define MW_SCI_B_ENABLELOOPBACK 0\n#define MW_SCI_B_SUSPENSIONMODE 2\n#define MW_SCI_B_NUMBEROFSTOPBITS 0\n#define MW_SCI_B_PARITYMODE 0\n#define MW_SCI_B_CHARACTERLENGTHBITS 0\n#define MW_SCI_B_USERBAUDRATE 115200\n#define MW_SCI_B_BAUDRATEPRESCALER 108.000000\n#define MW_SCI_B_BAUDRATE 114679.000000\n#define MW_SCI_B_COMMUNICATIONMODE 0\n#define MW_SCI_B_BLOCKINGMODE 0\n#define MW_SCI_B_DATABYTEORDER 0\n#define MW_SCI_B_DATASWAPWIDTH 0\n#define MW_SCI_B_PINASSIGNMENT_TX 1\n#define MW_SCI_B_PINASSIGNMENT_RX 1\n#define MW_SPI_A_MODE 0\n#define MW_SPI_A_USERBAUDRATE 1843200\n#define MW_SPI_A_BAUDRATEFACTOR 53.000000\n#define MW_SPI_A_BAUDRATE 1851852.000000\n#define MW_SPI_A_DATABITS 15\n#define MW_SPI_A_CLOCKPOLARITY \n#define MW_SPI_A_CLOCKPHASE \n#define MW_SPI_A_SUSPENSIONMODE 2\n#define MW_SPI_A_ENABLELOOPBACK 0\n#define MW_SPI_A_ENABLETHREEWIRE 0\n#define MW_SPI_A_TXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_A_RXINTERRUPTENABLE 0\n#define MW_SPI_A_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_A_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_A_FIFOENABLE 1\n#define MW_SPI_A_FIFOTRANSMITDELAY 0\n#define MW_SPI_A_PINASSIGNMENT_SIMO 2\n#define MW_SPI_A_PINASSIGNMENT_SOMI 2\n#define MW_SPI_A_PINASSIGNMENT_CLK 2\n#define MW_SPI_A_PINASSIGNMENT_STE 2\n#define MW_SPI_A_PINVALUE_SIMO 16\n#define MW_SPI_A_PINVALUE_SOMI 17\n#define MW_SPI_A_PINVALUE_CLK 9\n#define MW_SPI_A_PINVALUE_STE 11\n#define MW_SPI_A_PINMUX_SIMO 1\n#define MW_SPI_A_PINMUX_SOMI 1\n#define MW_SPI_A_PINMUX_CLK 7\n#define MW_SPI_A_PINMUX_STE 7\n#define MW_SPI_A_FIFO_LEVEL 16.000000\n#define MW_SPI_B_MODE 0\n#define MW_SPI_B_USERBAUDRATE 1843200\n#define MW_SPI_B_BAUDRATEFACTOR 53.000000\n#define MW_SPI_B_BAUDRATE 1851852.000000\n#define MW_SPI_B_DATABITS 15\n#define MW_SPI_B_CLOCKPOLARITY 0\n#define MW_SPI_B_CLOCKPHASE 0\n#define MW_SPI_B_SUSPENSIONMODE 2\n#define MW_SPI_B_ENABLELOOPBACK 0\n#define MW_SPI_B_ENABLETHREEWIRE 0\n#define MW_SPI_B_TXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_TX 0\n#define MW_SPI_B_RXINTERRUPTENABLE 0\n#define MW_SPI_B_FIFOINTERRUPTLEVEL_RX 16\n#define MW_SPI_B_ENABLEHIGHSPEEDMODE 1\n#define MW_SPI_B_FIFOENABLE 1\n#define MW_SPI_B_FIFOTRANSMITDELAY 0\n#define MW_SPI_B_PINASSIGNMENT_SIMO 2\n#define MW_SPI_B_PINASSIGNMENT_SOMI 2\n#define MW_SPI_B_PINASSIGNMENT_CLK 3\n#define MW_SPI_B_PINASSIGNMENT_STE 2\n#define MW_SPI_B_PINVALUE_SIMO 24\n#define MW_SPI_B_PINVALUE_SOMI 25\n#define MW_SPI_B_PINVALUE_CLK 26\n#define MW_SPI_B_PINVALUE_STE 27\n#define MW_SPI_B_PINMUX_SIMO 6\n#define MW_SPI_B_PINMUX_SOMI 6\n#define MW_SPI_B_PINMUX_CLK 6\n#define MW_SPI_B_PINMUX_STE 6\n#define MW_SPI_B_FIFO_LEVEL 16.000000\n#define MW_ECAN_A_MODULECLOCKFREQUENCY 100\n#define MW_ECAN_A_BAUDRATEPRESCALER 10.000000\n#define MW_ECAN_A_TSEG1 4\n#define MW_ECAN_A_TSEG2 3\n#define MW_ECAN_A_BAUDRATE 1000000\n#define MW_ECAN_A_SBG 0\n#define MW_ECAN_A_SJW 1\n#define MW_ECAN_A_SAM 0\n#define MW_ECAN_A_ENHANCEDCANMODE 1\n#define MW_ECAN_A_SELFTESTMODE 0\n#define MW_ECAN_A_PINASSIGNMENT_TX 3\n#define MW_ECAN_A_PINASSIGNMENT_RX 3\n#define MW_ECAN_B_MODULECLOCKFREQUENCY 100\n#define MW_ECAN_B_BAUDRATEPRESCALER 10.000000\n#define MW_ECAN_B_TSEG1 4\n#define MW_ECAN_B_TSEG2 3\n#define MW_ECAN_B_BAUDRATE 1000000\n#define MW_ECAN_B_SBG 0\n#define MW_ECAN_B_SJW 1\n#define MW_ECAN_B_SAM 0\n#define MW_ECAN_B_ENHANCEDCANMODE 1\n#define MW_ECAN_B_SELFTESTMODE 0\n#define MW_ECAN_B_PINASSIGNMENT_TX 5\n#define MW_ECAN_B_PINASSIGNMENT_RX 6\n#define MW_SDFM1_F1 0\n#define MW_SDFM1_D1 0\n#define MW_SDFM1_C1 0\n#define MW_SDFM1_F1_MODE 0\n#define MW_SDFM1_F1_C_FILTERTYPE 1\n#define MW_SDFM1_F1_COSR 0\n#define MW_SDFM1_F1_HLT 0\n#define MW_SDFM1_F1_LLT 0\n#define MW_SDFM1_F1_HLTZ 0\n#define MW_SDFM1_F1_D_FILTERTYPE 1\n#define MW_SDFM1_F1_DOSR 0\n#define MW_SDFM1_F1_FIFO 0\n#define MW_SDFM1_F1_EXTPWM 0\n#define MW_SDFM1_F1_EXTPWM_MOD 0\n#define MW_SDFM1_F1_IEL 0\n#define MW_SDFM1_F1_IEH 0\n#define MW_SDFM1_F1_IEHZ 0\n#define MW_SDFM1_F1_MFIE 0\n#define MW_SDFM1_F1_AE 0\n#define MW_SDFM1_F2 0\n#define MW_SDFM1_D2 0\n#define MW_SDFM1_C2 0\n#define MW_SDFM1_F2_MODE 0\n#define MW_SDFM1_F2_C_FILTERTYPE 1\n#define MW_SDFM1_F2_COSR 0\n#define MW_SDFM1_F2_HLT 0\n#define MW_SDFM1_F2_LLT 0\n#define MW_SDFM1_F2_HLTZ 0\n#define MW_SDFM1_F2_D_FILTERTYPE 1\n#define MW_SDFM1_F2_DOSR 0\n#define MW_SDFM1_F2_FIFO 0\n#define MW_SDFM1_F2_EXTPWM 0\n#define MW_SDFM1_F2_EXTPWM_MOD 0\n#define MW_SDFM1_F2_IEL 0\n#define MW_SDFM1_F2_IEH 0\n#define MW_SDFM1_F2_IEHZ 0\n#define MW_SDFM1_F2_MFIE 0\n#define MW_SDFM1_F2_AE 0\n#define MW_SDFM1_F3 0\n#define MW_SDFM1_D3 0\n#define MW_SDFM1_C3 0\n#define MW_SDFM1_F3_MODE 0\n#define MW_SDFM1_F3_C_FILTERTYPE 1\n#define MW_SDFM1_F3_COSR 0\n#define MW_SDFM1_F3_HLT 0\n#define MW_SDFM1_F3_LLT 0\n#define MW_SDFM1_F3_HLTZ 0\n#define MW_SDFM1_F3_D_FILTERTYPE 1\n#define MW_SDFM1_F3_DOSR 0\n#define MW_SDFM1_F3_FIFO 0\n#define MW_SDFM1_F3_EXTPWM 0\n#define MW_SDFM1_F3_EXTPWM_MOD 0\n#define MW_SDFM1_F3_IEL 0\n#define MW_SDFM1_F3_IEH 0\n#define MW_SDFM1_F3_IEHZ 0\n#define MW_SDFM1_F3_MFIE 0\n#define MW_SDFM1_F3_AE 0\n#define MW_SDFM1_F4 0\n#define MW_SDFM1_D4 0\n#define MW_SDFM1_C4 0\n#define MW_SDFM1_F4_MODE 0\n#define MW_SDFM1_F4_C_FILTERTYPE 1\n#define MW_SDFM1_F4_COSR 0\n#define MW_SDFM1_F4_HLT 0\n#define MW_SDFM1_F4_LLT 0\n#define MW_SDFM1_F4_HLTZ 0\n#define MW_SDFM1_F4_D_FILTERTYPE 1\n#define MW_SDFM1_F4_DOSR 0\n#define MW_SDFM1_F4_FIFO 0\n#define MW_SDFM1_F4_EXTPWM 0\n#define MW_SDFM1_F4_EXTPWM_MOD 0\n#define MW_SDFM1_F4_IEL 0\n#define MW_SDFM1_F4_IEH 0\n#define MW_SDFM1_F4_IEHZ 0\n#define MW_SDFM1_F4_MFIE 0\n#define MW_SDFM1_F4_AE 0\n#define MW_SDFM1_PINVALUE_D1 16\n#define MW_SDFM1_PINVALUE_C1 17\n#define MW_SDFM1_PINVALUE_D2 18\n#define MW_SDFM1_PINVALUE_C2 27\n#define MW_SDFM1_PINVALUE_D3 28\n#define MW_SDFM1_PINVALUE_C3 29\n#define MW_SDFM1_PINVALUE_D4 22\n#define MW_SDFM1_PINVALUE_C4 31\n#define MW_SDFM1_PINMUX_D1 7\n#define MW_SDFM1_PINMUX_C1 7\n#define MW_SDFM1_PINMUX_D2 7\n#define MW_SDFM1_PINMUX_C2 7\n#define MW_SDFM1_PINMUX_D3 7\n#define MW_SDFM1_PINMUX_C3 7\n#define MW_SDFM1_PINMUX_D4 7\n#define MW_SDFM1_PINMUX_C4 7\n#define MW_WATCHDOG_ENABLE_WATCHDOG 0\n#define MW_WATCHDOG_WATCHDOGCLOCKPREDIVIDER 8\n#define MW_WATCHDOG_WATCHDOGCLOCKPRESCALER 0\n#define MW_WATCHDOG_WATCHDOGCLOCK OSCCLK/512/1\n#define MW_WATCHDOG_TIME_PERIOD 0.013107\n#define MW_WATCHDOG_WATCHDOGEVENT 0\n#define MW_GPIO0_7_GPIOQUALSEL0 0\n#define MW_GPIO0_7_GPIOQUALSEL1 0\n#define MW_GPIO0_7_GPIOQUALSEL2 0\n#define MW_GPIO0_7_GPIOQUALSEL3 0\n#define MW_GPIO0_7_GPIOQUALSEL4 0\n#define MW_GPIO0_7_GPIOQUALSEL5 0\n#define MW_GPIO0_7_GPIOQUALSEL6 0\n#define MW_GPIO0_7_GPIOQUALSEL7 0\n#define MW_GPIO0_7_QUALPRD 0\n#define MW_GPIO8_15_GPIOQUALSEL8 0\n#define MW_GPIO8_15_GPIOQUALSEL9 0\n#define MW_GPIO8_15_GPIOQUALSEL10 0\n#define MW_GPIO8_15_GPIOQUALSEL11 0\n#define MW_GPIO8_15_GPIOQUALSEL12 0\n#define MW_GPIO8_15_GPIOQUALSEL13 0\n#define MW_GPIO8_15_GPIOQUALSEL14 0\n#define MW_GPIO8_15_GPIOQUALSEL15 0\n#define MW_GPIO8_15_QUALPRD 0\n#define MW_GPIO16_23_GPIOQUALSEL16 0\n#define MW_GPIO16_23_GPIOQUALSEL17 0\n#define MW_GPIO16_23_GPIOQUALSEL18 0\n#define MW_GPIO16_23_GPIOQUALSEL19 0\n#define MW_GPIO16_23_GPIOQUALSEL20 0\n#define MW_GPIO16_23_GPIOQUALSEL21 0\n#define MW_GPIO16_23_GPIOQUALSEL22 0\n#define MW_GPIO16_23_GPIOQUALSEL23 0\n#define MW_GPIO16_23_QUALPRD 0\n#define MW_GPIO24_31_GPIOQUALSEL24 0\n#define MW_GPIO24_31_GPIOQUALSEL25 0\n#define MW_GPIO24_31_GPIOQUALSEL26 0\n#define MW_GPIO24_31_GPIOQUALSEL27 0\n#define MW_GPIO24_31_GPIOQUALSEL28 0\n#define MW_GPIO24_31_GPIOQUALSEL29 0\n#define MW_GPIO24_31_GPIOQUALSEL30 0\n#define MW_GPIO24_31_GPIOQUALSEL31 0\n#define MW_GPIO24_31_QUALPRD 0\n#define MW_GPIO32_39_GPIOQUALSEL32 0\n#define MW_GPIO32_39_GPIOQUALSEL33 0\n#define MW_GPIO32_39_GPIOQUALSEL34 0\n#define MW_GPIO32_39_GPIOQUALSEL35 0\n#define MW_GPIO32_39_GPIOQUALSEL37 0\n#define MW_GPIO32_39_GPIOQUALSEL39 0\n#define MW_GPIO32_39_QUALPRD 0\n#define MW_GPIO40_47_GPIOQUALSEL40 0\n#define MW_GPIO40_47_GPIOQUALSEL41 0\n#define MW_GPIO40_47_GPIOQUALSEL42 0\n#define MW_GPIO40_47_GPIOQUALSEL43 0\n#define MW_GPIO40_47_GPIOQUALSEL44 0\n#define MW_GPIO40_47_GPIOQUALSEL45 0\n#define MW_GPIO40_47_GPIOQUALSEL46 0\n#define MW_GPIO40_47_GPIOQUALSEL47 0\n#define MW_GPIO40_47_QUALPRD 0\n#define MW_GPIO48_55_GPIOQUALSEL48 0\n#define MW_GPIO48_55_GPIOQUALSEL49 0\n#define MW_GPIO48_55_GPIOQUALSEL50 0\n#define MW_GPIO48_55_GPIOQUALSEL51 0\n#define MW_GPIO48_55_GPIOQUALSEL52 0\n#define MW_GPIO48_55_GPIOQUALSEL53 0\n#define MW_GPIO48_55_GPIOQUALSEL54 0\n#define MW_GPIO48_55_GPIOQUALSEL55 0\n#define MW_GPIO48_55_QUALPRD 0\n#define MW_GPIO56_63_GPIOQUALSEL56 0\n#define MW_GPIO56_63_GPIOQUALSEL57 0\n#define MW_GPIO56_63_GPIOQUALSEL58 0\n#define MW_GPIO56_63_GPIOQUALSEL59 0\n#define MW_GPIO56_63_QUALPRD 0\n#define MW_DMA_CH1_ENABLEDMACHANNEL 0\n#define MW_DMA_CH1_DATASIZE 0\n#define MW_DMA_CH1_INTERRUPTSRC 0\n#define MW_DMA_CH1_BURSTSIZE 0\n#define MW_DMA_CH1_TRANSFERSIZE 1\n#define MW_DMA_CH1_SRCBEGINADD 0xC000\n#define MW_DMA_CH1_DSTBEGINADD 0xD000\n#define MW_DMA_CH1_SRCBURSTSTEP 0\n#define MW_DMA_CH1_DSTBURSTSTEP 0\n#define MW_DMA_CH1_SRCTRANSSTEP 0\n#define MW_DMA_CH1_DSTTRANSSTEP 0\n#define MW_DMA_CH1_WRAPSRCSIZE 65536\n#define MW_DMA_CH1_WRAPDSTSIZE 65536\n#define MW_DMA_CH1_SRCWRAPSTEP 0\n#define MW_DMA_CH1_DSTWRAPSTEP 0\n#define MW_DMA_CH1_SETCH1TOHIGH 0\n#define MW_DMA_CH1_ENABLEONESHOT 0\n#define MW_DMA_CH1_ENABLECONTINUOUS 1\n#define MW_DMA_CH1_GENINTERRUPT 0\n#define MW_DMA_CH1_ENABLEOVERFLOW 0\n#define MW_DMA_CH2_ENABLEDMACHANNEL 0\n#define MW_DMA_CH2_DATASIZE 0\n#define MW_DMA_CH2_INTERRUPTSRC 0\n#define MW_DMA_CH2_BURSTSIZE 0\n#define MW_DMA_CH2_TRANSFERSIZE 1\n#define MW_DMA_CH2_SRCBEGINADD 0xC000\n#define MW_DMA_CH2_DSTBEGINADD 0xD000\n#define MW_DMA_CH2_SRCBURSTSTEP 0\n#define MW_DMA_CH2_DSTBURSTSTEP 0\n#define MW_DMA_CH2_SRCTRANSSTEP 0\n#define MW_DMA_CH2_DSTTRANSSTEP 0\n#define MW_DMA_CH2_WRAPSRCSIZE 65536\n#define MW_DMA_CH2_WRAPDSTSIZE 65536\n#define MW_DMA_CH2_SRCWRAPSTEP 0\n#define MW_DMA_CH2_DSTWRAPSTEP 0\n#define MW_DMA_CH2_ENABLEONESHOT 0\n#define MW_DMA_CH2_ENABLECONTINUOUS 1\n#define MW_DMA_CH2_GENINTERRUPT 0\n#define MW_DMA_CH2_ENABLEOVERFLOW 0\n#define MW_DMA_CH3_ENABLEDMACHANNEL 0\n#define MW_DMA_CH3_DATASIZE 0\n#define MW_DMA_CH3_INTERRUPTSRC 0\n#define MW_DMA_CH3_BURSTSIZE 0\n#define MW_DMA_CH3_TRANSFERSIZE 1\n#define MW_DMA_CH3_SRCBEGINADD 0xC000\n#define MW_DMA_CH3_DSTBEGINADD 0xD000\n#define MW_DMA_CH3_SRCBURSTSTEP 0\n#define MW_DMA_CH3_DSTBURSTSTEP 0\n#define MW_DMA_CH3_SRCTRANSSTEP 0\n#define MW_DMA_CH3_DSTTRANSSTEP 0\n#define MW_DMA_CH3_WRAPSRCSIZE 65536\n#define MW_DMA_CH3_WRAPDSTSIZE 65536\n#define MW_DMA_CH3_SRCWRAPSTEP 0\n#define MW_DMA_CH3_DSTWRAPSTEP 0\n#define MW_DMA_CH3_ENABLEONESHOT 0\n#define MW_DMA_CH3_ENABLECONTINUOUS 1\n#define MW_DMA_CH3_GENINTERRUPT 0\n#define MW_DMA_CH3_ENABLEOVERFLOW 0\n#define MW_DMA_CH4_ENABLEDMACHANNEL 0\n#define MW_DMA_CH4_DATASIZE 0\n#define MW_DMA_CH4_INTERRUPTSRC 0\n#define MW_DMA_CH4_BURSTSIZE 0\n#define MW_DMA_CH4_TRANSFERSIZE 1\n#define MW_DMA_CH4_SRCBEGINADD 0xC000\n#define MW_DMA_CH4_DSTBEGINADD 0xD000\n#define MW_DMA_CH4_SRCBURSTSTEP 0\n#define MW_DMA_CH4_DSTBURSTSTEP 0\n#define MW_DMA_CH4_SRCTRANSSTEP 0\n#define MW_DMA_CH4_DSTTRANSSTEP 0\n#define MW_DMA_CH4_WRAPSRCSIZE 65536\n#define MW_DMA_CH4_WRAPDSTSIZE 65536\n#define MW_DMA_CH4_SRCWRAPSTEP 0\n#define MW_DMA_CH4_DSTWRAPSTEP 0\n#define MW_DMA_CH4_ENABLEONESHOT 0\n#define MW_DMA_CH4_ENABLECONTINUOUS 1\n#define MW_DMA_CH4_GENINTERRUPT 0\n#define MW_DMA_CH4_ENABLEOVERFLOW 0\n#define MW_DMA_CH5_ENABLEDMACHANNEL 0\n#define MW_DMA_CH5_DATASIZE 0\n#define MW_DMA_CH5_INTERRUPTSRC 0\n#define MW_DMA_CH5_BURSTSIZE 0\n#define MW_DMA_CH5_TRANSFERSIZE 1\n#define MW_DMA_CH5_SRCBEGINADD 0xC000\n#define MW_DMA_CH5_DSTBEGINADD 0xD000\n#define MW_DMA_CH5_SRCBURSTSTEP 0\n#define MW_DMA_CH5_DSTBURSTSTEP 0\n#define MW_DMA_CH5_SRCTRANSSTEP 0\n#define MW_DMA_CH5_DSTTRANSSTEP 0\n#define MW_DMA_CH5_WRAPSRCSIZE 65536\n#define MW_DMA_CH5_WRAPDSTSIZE 65536\n#define MW_DMA_CH5_SRCWRAPSTEP 0\n#define MW_DMA_CH5_DSTWRAPSTEP 0\n#define MW_DMA_CH5_ENABLEONESHOT 0\n#define MW_DMA_CH5_ENABLECONTINUOUS 1\n#define MW_DMA_CH5_GENINTERRUPT 0\n#define MW_DMA_CH5_ENABLEOVERFLOW 0\n#define MW_DMA_CH6_ENABLEDMACHANNEL 0\n#define MW_DMA_CH6_DATASIZE 0\n#define MW_DMA_CH6_INTERRUPTSRC 0\n#define MW_DMA_CH6_BURSTSIZE 0\n#define MW_DMA_CH6_TRANSFERSIZE 1\n#define MW_DMA_CH6_SRCBEGINADD 0xC000\n#define MW_DMA_CH6_DSTBEGINADD 0xD000\n#define MW_DMA_CH6_SRCBURSTSTEP 0\n#define MW_DMA_CH6_DSTBURSTSTEP 0\n#define MW_DMA_CH6_SRCTRANSSTEP 0\n#define MW_DMA_CH6_DSTTRANSSTEP 0\n#define MW_DMA_CH6_WRAPSRCSIZE 65536\n#define MW_DMA_CH6_WRAPDSTSIZE 65536\n#define MW_DMA_CH6_SRCWRAPSTEP 0\n#define MW_DMA_CH6_DSTWRAPSTEP 0\n#define MW_DMA_CH6_ENABLEONESHOT 0\n#define MW_DMA_CH6_ENABLECONTINUOUS 1\n#define MW_DMA_CH6_GENINTERRUPT 0\n#define MW_DMA_CH6_ENABLEOVERFLOW 0\n#define MW_XINT_GPIOXINT1SEL_IXBAR 0\n#define MW_XINT_GPIOXINT2SEL_IXBAR 0\n#define MW_XINT_GPIOXINT3SEL_IXBAR 0\n#define MW_XINT_GPIOXINT4SEL_IXBAR 0\n#define MW_XINT_GPIOXINT5SEL_IXBAR 0\n#define MW_XINT_GPIOXINT1SEL 58\n#define MW_XINT_GPIOXINT2SEL 58\n#define MW_XINT_GPIOXINT3SEL 58\n#define MW_XINT_GPIOXINT4SEL 56\n#define MW_XINT_GPIOXINT5SEL 58\n#define MW_XINT_POLARITY1 0\n#define MW_XINT_POLARITY2 0\n#define MW_XINT_POLARITY3 0\n#define MW_XINT_POLARITY4 0\n#define MW_XINT_POLARITY5 0\n#define MW_PIL_COMMUNICATIONINTERFACE 0\n#define MW_PIL_SCIMODULE 0\n#define MW_PIL_COMPORT COM4\n#define MW_EXTMODECOMPORT -1\n#define MW_EXECUTIONPROFILEBUFFERLEN 50.000000\n#define MW_SDCARD_ENABLE 0\n#define MW_SDCARD_SPIMODULE 0\n#define MW_SDCARD_SPIBAUDRATE 1\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_CHECK_GPIO_STATUS 1\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 34\n#define MW_OVERRUNDETECTION_GPIOMODE 0\n#define MW_OVERRUNDETECTION_CUSTOM_LOGIC 0\n#define MW_OVERRUNDETECTION_PIE_NUMBER 0\n#define MW_OVERRUNDETECTION_CPU_NUMBER 0\n#define MW_OVERRUNDETECTION_CUSTOM_FUNCTION c2000_OverrunFunction\n#define MW_DATAVERSION 2016.02\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONCAN_LOGGINGBUFFERNUM 3\n#define MW_CLBXBAR_AUXSIG0 0\n#define MW_CLBXBAR_AUXSIG_MUX0 -1\n#define MW_CLBXBAR_AUXSIG0_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG0_INVERT 0\n#define MW_CLBXBAR_AUXSIG1 0\n#define MW_CLBXBAR_AUXSIG_MUX1 -1\n#define MW_CLBXBAR_AUXSIG1_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG1_INVERT 0\n#define MW_CLBXBAR_AUXSIG2 0\n#define MW_CLBXBAR_AUXSIG_MUX2 -1\n#define MW_CLBXBAR_AUXSIG2_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG2_INVERT 0\n#define MW_CLBXBAR_AUXSIG3 0\n#define MW_CLBXBAR_AUXSIG_MUX3 -1\n#define MW_CLBXBAR_AUXSIG3_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG3_INVERT 0\n#define MW_CLBXBAR_AUXSIG4 0\n#define MW_CLBXBAR_AUXSIG_MUX4 -1\n#define MW_CLBXBAR_AUXSIG4_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG4_INVERT 0\n#define MW_CLBXBAR_AUXSIG5 0\n#define MW_CLBXBAR_AUXSIG_MUX5 -1\n#define MW_CLBXBAR_AUXSIG5_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG5_INVERT 0\n#define MW_CLBXBAR_AUXSIG6 0\n#define MW_CLBXBAR_AUXSIG_MUX6 -1\n#define MW_CLBXBAR_AUXSIG6_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG6_INVERT 0\n#define MW_CLBXBAR_AUXSIG7 0\n#define MW_CLBXBAR_AUXSIG_MUX7 -1\n#define MW_CLBXBAR_AUXSIG7_MUXSELECT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n#define MW_CLBXBAR_AUXSIG7_INVERT 0\n#define MW_CLB_TILE1 0\n#define MW_CLB_TILE1_NAME TILE1\n#define MW_CLB_TILE1_IN0_MUX 0\n#define MW_CLB_TILE1_IN0 -1\n#define MW_CLB_TILE1_IN0_FILTER 0\n#define MW_CLB_TILE1_IN0_SYNC 0\n#define MW_CLB_TILE1_IN1_MUX 0\n#define MW_CLB_TILE1_IN1 -1\n#define MW_CLB_TILE1_IN1_FILTER 0\n#define MW_CLB_TILE1_IN1_SYNC 0\n#define MW_CLB_TILE1_IN2_MUX 0\n#define MW_CLB_TILE1_IN2 -1\n#define MW_CLB_TILE1_IN2_FILTER 0\n#define MW_CLB_TILE1_IN2_SYNC 0\n#define MW_CLB_TILE1_IN3_MUX 0\n#define MW_CLB_TILE1_IN3 -1\n#define MW_CLB_TILE1_IN3_FILTER 0\n#define MW_CLB_TILE1_IN3_SYNC 0\n#define MW_CLB_TILE1_IN4_MUX 0\n#define MW_CLB_TILE1_IN4 -1\n#define MW_CLB_TILE1_IN4_FILTER 0\n#define MW_CLB_TILE1_IN4_SYNC 0\n#define MW_CLB_TILE1_IN5_MUX 0\n#define MW_CLB_TILE1_IN5 -1\n#define MW_CLB_TILE1_IN5_FILTER 0\n#define MW_CLB_TILE1_IN5_SYNC 0\n#define MW_CLB_TILE1_IN6_MUX 0\n#define MW_CLB_TILE1_IN6 -1\n#define MW_CLB_TILE1_IN6_FILTER 0\n#define MW_CLB_TILE1_IN6_SYNC 0\n#define MW_CLB_TILE1_IN7_MUX 0\n#define MW_CLB_TILE1_IN7 -1\n#define MW_CLB_TILE1_IN7_FILTER 0\n#define MW_CLB_TILE1_IN7_SYNC 0\n#define MW_CLB_TILE1_OUT0_0 0\n#define MW_CLB_TILE1_OUT0_1 0\n#define MW_CLB_TILE1_OUT0_2 0\n#define MW_CLB_TILE1_OUT1_0 0\n#define MW_CLB_TILE1_OUT1_1 0\n#define MW_CLB_TILE1_OUT1_2 0\n#define MW_CLB_TILE1_OUT2_0 0\n#define MW_CLB_TILE1_OUT2_1 0\n#define MW_CLB_TILE1_OUT2_2 0\n#define MW_CLB_TILE1_OUT3_0 0\n#define MW_CLB_TILE1_OUT3_1 0\n#define MW_CLB_TILE1_OUT3_2 0\n#define MW_CLB_TILE1_OUT4_0 0\n#define MW_CLB_TILE1_OUT4_1 0\n#define MW_CLB_TILE1_OUT4_2 0\n#define MW_CLB_TILE1_OUT5_0 0\n#define MW_CLB_TILE1_OUT5_1 0\n#define MW_CLB_TILE1_OUT5_2 0\n#define MW_CLB_TILE1_OUT6_0 0\n#define MW_CLB_TILE1_OUT6_1 0\n#define MW_CLB_TILE1_OUT6_2 0\n#define MW_CLB_TILE1_OUT7_0 0\n#define MW_CLB_TILE1_OUT7_1 0\n#define MW_CLB_TILE1_OUT7_2 0\n#define MW_CLB_TILE2 0\n#define MW_CLB_TILE2_NAME TILE2\n#define MW_CLB_TILE2_IN0_MUX 0\n#define MW_CLB_TILE2_IN0 -1\n#define MW_CLB_TILE2_IN0_FILTER 0\n#define MW_CLB_TILE2_IN0_SYNC 0\n#define MW_CLB_TILE2_IN1_MUX 0\n#define MW_CLB_TILE2_IN1 -1\n#define MW_CLB_TILE2_IN1_FILTER 0\n#define MW_CLB_TILE2_IN1_SYNC 0\n#define MW_CLB_TILE2_IN2_MUX 0\n#define MW_CLB_TILE2_IN2 -1\n#define MW_CLB_TILE2_IN2_FILTER 0\n#define MW_CLB_TILE2_IN2_SYNC 0\n#define MW_CLB_TILE2_IN3_MUX 0\n#define MW_CLB_TILE2_IN3 -1\n#define MW_CLB_TILE2_IN3_FILTER 0\n#define MW_CLB_TILE2_IN3_SYNC 0\n#define MW_CLB_TILE2_IN4_MUX 0\n#define MW_CLB_TILE2_IN4 -1\n#define MW_CLB_TILE2_IN4_FILTER 0\n#define MW_CLB_TILE2_IN4_SYNC 0\n#define MW_CLB_TILE2_IN5_MUX 0\n#define MW_CLB_TILE2_IN5 -1\n#define MW_CLB_TILE2_IN5_FILTER 0\n#define MW_CLB_TILE2_IN5_SYNC 0\n#define MW_CLB_TILE2_IN6_MUX 0\n#define MW_CLB_TILE2_IN6 -1\n#define MW_CLB_TILE2_IN6_FILTER 0\n#define MW_CLB_TILE2_IN6_SYNC 0\n#define MW_CLB_TILE2_IN7_MUX 0\n#define MW_CLB_TILE2_IN7 -1\n#define MW_CLB_TILE2_IN7_FILTER 0\n#define MW_CLB_TILE2_IN7_SYNC 0\n#define MW_CLB_TILE2_OUT0_0 0\n#define MW_CLB_TILE2_OUT0_1 0\n#define MW_CLB_TILE2_OUT0_2 0\n#define MW_CLB_TILE2_OUT1_0 0\n#define MW_CLB_TILE2_OUT1_1 0\n#define MW_CLB_TILE2_OUT1_2 0\n#define MW_CLB_TILE2_OUT2_0 0\n#define MW_CLB_TILE2_OUT2_1 0\n#define MW_CLB_TILE2_OUT2_2 0\n#define MW_CLB_TILE2_OUT3_0 0\n#define MW_CLB_TILE2_OUT3_1 0\n#define MW_CLB_TILE2_OUT3_2 0\n#define MW_CLB_TILE2_OUT4_0 0\n#define MW_CLB_TILE2_OUT4_1 0\n#define MW_CLB_TILE2_OUT4_2 0\n#define MW_CLB_TILE2_OUT5_0 0\n#define MW_CLB_TILE2_OUT5_1 0\n#define MW_CLB_TILE2_OUT5_2 0\n#define MW_CLB_TILE2_OUT6_0 0\n#define MW_CLB_TILE2_OUT6_1 0\n#define MW_CLB_TILE2_OUT6_2 0\n#define MW_CLB_TILE2_OUT7_0 0\n#define MW_CLB_TILE2_OUT7_1 0\n#define MW_CLB_TILE2_OUT7_2 0\n#define MW_CLB_TILE3 0\n#define MW_CLB_TILE3_NAME TILE3\n#define MW_CLB_TILE3_IN0_MUX 0\n#define MW_CLB_TILE3_IN0 -1\n#define MW_CLB_TILE3_IN0_FILTER 0\n#define MW_CLB_TILE3_IN0_SYNC 0\n#define MW_CLB_TILE3_IN1_MUX 0\n#define MW_CLB_TILE3_IN1 -1\n#define MW_CLB_TILE3_IN1_FILTER 0\n#define MW_CLB_TILE3_IN1_SYNC 0\n#define MW_CLB_TILE3_IN2_MUX 0\n#define MW_CLB_TILE3_IN2 -1\n#define MW_CLB_TILE3_IN2_FILTER 0\n#define MW_CLB_TILE3_IN2_SYNC 0\n#define MW_CLB_TILE3_IN3_MUX 0\n#define MW_CLB_TILE3_IN3 -1\n#define MW_CLB_TILE3_IN3_FILTER 0\n#define MW_CLB_TILE3_IN3_SYNC 0\n#define MW_CLB_TILE3_IN4_MUX 0\n#define MW_CLB_TILE3_IN4 -1\n#define MW_CLB_TILE3_IN4_FILTER 0\n#define MW_CLB_TILE3_IN4_SYNC 0\n#define MW_CLB_TILE3_IN5_MUX 0\n#define MW_CLB_TILE3_IN5 -1\n#define MW_CLB_TILE3_IN5_FILTER 0\n#define MW_CLB_TILE3_IN5_SYNC 0\n#define MW_CLB_TILE3_IN6_MUX 0\n#define MW_CLB_TILE3_IN6 -1\n#define MW_CLB_TILE3_IN6_FILTER 0\n#define MW_CLB_TILE3_IN6_SYNC 0\n#define MW_CLB_TILE3_IN7_MUX 0\n#define MW_CLB_TILE3_IN7 -1\n#define MW_CLB_TILE3_IN7_FILTER 0\n#define MW_CLB_TILE3_IN7_SYNC 0\n#define MW_CLB_TILE3_OUT0_0 0\n#define MW_CLB_TILE3_OUT0_1 0\n#define MW_CLB_TILE3_OUT0_2 0\n#define MW_CLB_TILE3_OUT1_0 0\n#define MW_CLB_TILE3_OUT1_1 0\n#define MW_CLB_TILE3_OUT1_2 0\n#define MW_CLB_TILE3_OUT2_0 0\n#define MW_CLB_TILE3_OUT2_1 0\n#define MW_CLB_TILE3_OUT2_2 0\n#define MW_CLB_TILE3_OUT3_0 0\n#define MW_CLB_TILE3_OUT3_1 0\n#define MW_CLB_TILE3_OUT3_2 0\n#define MW_CLB_TILE3_OUT4_0 0\n#define MW_CLB_TILE3_OUT4_1 0\n#define MW_CLB_TILE3_OUT4_2 0\n#define MW_CLB_TILE3_OUT5_0 0\n#define MW_CLB_TILE3_OUT5_1 0\n#define MW_CLB_TILE3_OUT6_0 0\n#define MW_CLB_TILE3_OUT6_1 0\n#define MW_CLB_TILE3_OUT6_2 0\n#define MW_CLB_TILE3_OUT7_0 0\n#define MW_CLB_TILE3_OUT7_1 0\n#define MW_CLB_TILE3_OUT7_2 0\n#define MW_CLB_TILE4 0\n#define MW_CLB_TILE4_NAME TILE4\n#define MW_CLB_TILE4_IN0_MUX 0\n#define MW_CLB_TILE4_IN0 -1\n#define MW_CLB_TILE4_IN0_FILTER 0\n#define MW_CLB_TILE4_IN0_SYNC 0\n#define MW_CLB_TILE4_IN1_MUX 0\n#define MW_CLB_TILE4_IN1 -1\n#define MW_CLB_TILE4_IN1_FILTER 0\n#define MW_CLB_TILE4_IN1_SYNC 0\n#define MW_CLB_TILE4_IN2_MUX 0\n#define MW_CLB_TILE4_IN2 -1\n#define MW_CLB_TILE4_IN2_FILTER 0\n#define MW_CLB_TILE4_IN2_SYNC 0\n#define MW_CLB_TILE4_IN3_MUX 0\n#define MW_CLB_TILE4_IN3 -1\n#define MW_CLB_TILE4_IN3_FILTER 0\n#define MW_CLB_TILE4_IN3_SYNC 0\n#define MW_CLB_TILE4_IN4_MUX 0\n#define MW_CLB_TILE4_IN4 -1\n#define MW_CLB_TILE4_IN4_FILTER 0\n#define MW_CLB_TILE4_IN4_SYNC 0\n#define MW_CLB_TILE4_IN5_MUX 0\n#define MW_CLB_TILE4_IN5 -1\n#define MW_CLB_TILE4_IN5_FILTER 0\n#define MW_CLB_TILE4_IN5_SYNC 0\n#define MW_CLB_TILE4_IN6_MUX 0\n#define MW_CLB_TILE4_IN6 -1\n#define MW_CLB_TILE4_IN6_FILTER 0\n#define MW_CLB_TILE4_IN6_SYNC 0\n#define MW_CLB_TILE4_IN7_MUX 0\n#define MW_CLB_TILE4_IN7 -1\n#define MW_CLB_TILE4_IN7_FILTER 0\n#define MW_CLB_TILE4_IN7_SYNC 0\n#define MW_CLB_TILE4_OUT0_0 0\n#define MW_CLB_TILE4_OUT0_1 0\n#define MW_CLB_TILE4_OUT0_2 0\n#define MW_CLB_TILE4_OUT1_0 0\n#define MW_CLB_TILE4_OUT1_1 0\n#define MW_CLB_TILE4_OUT1_2 0\n#define MW_CLB_TILE4_OUT2_0 0\n#define MW_CLB_TILE4_OUT2_1 0\n#define MW_CLB_TILE4_OUT2_2 0\n#define MW_CLB_TILE4_OUT3_0 0\n#define MW_CLB_TILE4_OUT3_1 0\n#define MW_CLB_TILE4_OUT3_2 0\n#define MW_CLB_TILE4_OUT4_0 0\n#define MW_CLB_TILE4_OUT4_1 0\n#define MW_CLB_TILE4_OUT4_2 0\n#define MW_CLB_TILE4_OUT5_0 0\n#define MW_CLB_TILE4_OUT5_1 0\n#define MW_CLB_TILE4_OUT5_2 0\n#define MW_CLB_TILE4_OUT6_0 0\n#define MW_CLB_TILE4_OUT6_1 0\n#define MW_CLB_TILE4_OUT6_2 0\n#define MW_CLB_TILE4_OUT7_0 0\n#define MW_CLB_TILE4_OUT7_1 0\n#define MW_CLB_TILE4_OUT7_2 0\n#define MW_CLB_HEADER clb_config.h\n#define MW_CLB_SOURCE clb_config.c\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"c28004xBoard_Realtime_Support.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"#include \"MW_target_hardware_resources.h\"\n#include <string.h>\n\n// The following values are used to validate PLL Frequency using DCC\n//\n#define   MW_PLL_RETRIES              100\n#define   MW_PLL_LOCK_TIMEOUT        2000\n#define   MW_DCC_COUNTER0_WINDOW      100\n\n#if MW_RUNTIME_FLASHLOAD\nextern Uint16 MW_RamfuncsRunStart;\nextern Uint16 MW_RamfuncsLoadSize;\nextern Uint16 MW_RamfuncsLoadStart;\n#endif\n\nextern Uint16 Cla1funcsRunStart;\nextern Uint16 Cla1funcsLoadStart;\nextern Uint16 Cla1funcsLoadSize;\nextern Uint16 Cla1mathTablesRunStart;\nextern Uint16 Cla1mathTablesLoadStart;\nextern Uint16 Cla1mathTablesLoadSize;\n\n\nvoid c2000_flash_init(void)\n{\n  #if MW_RUNTIME_FLASHLOAD\n  /* Copy InitFlash function code and Flash setup code to RAM */\n  memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t)&RamfuncsLoadSize);\n  memcpy(&MW_RamfuncsRunStart, &MW_RamfuncsLoadStart, (Uint32)&MW_RamfuncsLoadSize);\n  /* Call Flash Initialization to setup flash waitstates\n   This function must reside in RAM */\n  /* g2486589 - Standalone mode fix */\n  InitFlash();\n  #ifdef CLA_BLOCK_INCLUDED\n    memcpy(&Cla1funcsRunStart, &Cla1funcsLoadStart, (Uint32)&Cla1funcsLoadSize);\n    /*memcpy(&Cla1mathTablesRunStart, &Cla1mathTablesLoadStart, (Uint32)&Cla1mathTablesLoadSize); */\n  #endif  \n  #endif\n}\n\nbool MW_IsPLLValid(Uint16 oscSource, Uint16 imult, Uint16 fmult, Uint16 odiv)\n{\n    Uint32 dccCounterSeed0, dccCounterSeed1, dccValidSeed0;\n\n    //\n    // Setting Counter0 & Valid Seed Value with +/-2% tolerance\n    //\n    dccCounterSeed0 = MW_DCC_COUNTER0_WINDOW - 12U;\n    dccValidSeed0 = 24U;\n\n    //\n    // Multiplying Counter-0 window with PLL Integer Multiplier\n    //\n    dccCounterSeed1 = MW_DCC_COUNTER0_WINDOW * imult/(odiv + 1U);\n\n    //\n    // Multiplying Counter-0 window with PLL Fractional Multiplier\n    //\n    switch(fmult)\n    {\n        case FMULT_0pt25:\n            //\n            // FMULT * CNTR0 Window = 0.25 * 100 = 25, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 25U;\n            break;\n        case FMULT_0pt5:\n            //\n            // FMULT * CNTR0 Window = 0.5 * 100 = 50, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 50U;\n            break;\n        case FMULT_0pt75:\n            //\n            // FMULT * CNTR0 Window = 0.75 * 100 = 75, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 75U;\n            break;\n        default:\n            //\n            // No fractional multiplier\n            //\n            dccCounterSeed1 = dccCounterSeed1;\n            break;\n    }\n\n    //\n    // Enable Peripheral Clock Domain PCLKCR21 for DCC\n    //\n    EALLOW;\n    CpuSysRegs.PCLKCR21.bit.DCC_0 = 1;\n\n    //\n    // Clear Error & Done Flag\n    //\n    Dcc0Regs.DCCSTATUS.bit.ERR = 1;\n    Dcc0Regs.DCCSTATUS.bit.DONE = 1;\n\n    //\n    // Disable DCC\n    //\n    Dcc0Regs.DCCGCTRL.bit.DCCENA = 0x5;\n\n    //\n    // Disable Error Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.ERRENA = 0x5;\n\n    //\n    // Disable Done Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.DONEENA = 0x5;\n\n    //\n    // Configure Clock Source0 to whatever is set as a clock source for PLL\n    //\n    switch(oscSource)\n    {\n        case INT_OSC1:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 1; // Clk Src0 = INTOSC1\n            break;\n\n        case INT_OSC2:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 2; // Clk Src0 = INTOSC2\n            break;\n\n        case XTAL_OSC:\n        case XTAL_OSC_SE:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 0; // Clk Src0 = XTAL\n            break;\n    }\n\n    //\n    // Configure Clock Source1 to PLL\n    //\n    Dcc0Regs.DCCCLKSRC1.bit.KEY = 0xA; // Clk Src1 Key to enable clock source selection for count1\n    Dcc0Regs.DCCCLKSRC1.bit.CLKSRC1 = 0; // Clk Src1 = PLL\n\n    //\n    // Configure COUNTER-0, COUNTER-1 & Valid Window\n    //\n    Dcc0Regs.DCCCNTSEED0.bit.COUNTSEED0 = dccCounterSeed0; // Loaded Counter0 Value\n    Dcc0Regs.DCCVALIDSEED0.bit.VALIDSEED = dccValidSeed0;  // Loaded Valid Value\n    Dcc0Regs.DCCCNTSEED1.bit.COUNTSEED1 = dccCounterSeed1; // Loaded Counter1 Value\n\n    //\n    // Enable Single Shot Mode\n    //\n    Dcc0Regs.DCCGCTRL.bit.SINGLESHOT = 0xA;\n\n    //\n    // Enable Error Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.ERRENA = 0xA;\n\n    //\n    // Enable Done Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.DONEENA = 0xA;\n\n    //\n    // Enable DCC to start counting\n    //\n    Dcc0Regs.DCCGCTRL.bit.DCCENA = 0xA;\n    EDIS;\n\t\n    // Timeout for the loop\n    //\n    uint32_t timeout = dccCounterSeed1;\n\n    //\n    // Wait until Error or Done Flag is generated\n    //\n    while(((Dcc0Regs.DCCSTATUS.all & 3) == 0) && (timeout != 0U))\n    {\n\t\ttimeout--;\n    }\n\n    //\n    // Returns true if DCC completes without error\n    //\n    return(((Dcc0Regs.DCCSTATUS.all & 3) == 2) && \n\t(Dcc0Regs.DCCCNT0.bit.COUNT0 == 0) && \n\t(Dcc0Regs.DCCVALID0.bit.VALID0 == 0) && \n\t(Dcc0Regs.DCCCNT1.bit.COUNT1 == 0)) ;\n\n}\n\nvoid MW_InitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 odiv, Uint16 divsel)\n{\n    Uint32 timeout, retries, temp_syspllmult, pllLockStatus;\n    bool status;\n\n    if(((clock_source & 0x3) == ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)    &&\n       (((clock_source & 0x4) >> 2) == ClkCfgRegs.XTALCR.bit.SE)           &&\n                     (imult  == ClkCfgRegs.SYSPLLMULT.bit.IMULT)           &&\n                     (fmult  == ClkCfgRegs.SYSPLLMULT.bit.FMULT)           &&\n                     (odiv  == ClkCfgRegs.SYSPLLMULT.bit.ODIV)           &&\n                     (divsel == ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    if(((clock_source & 0x3) != ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL) ||\n       (((clock_source & 0x4) >> 2) != ClkCfgRegs.XTALCR.bit.SE))\n    {\n        switch (clock_source)\n        {\n            case INT_OSC1:\n                SysIntOsc1Sel();\n                break;\n\n            case INT_OSC2:\n                SysIntOsc2Sel();\n                break;\n\n            case XTAL_OSC:\n                SysXtalOscSel();\n                break;\n\n            case XTAL_OSC_SE:\n                SysXtalOscSESel();\n                break;\n        }\n    }\n\n    EALLOW;\n\n    //\n    // First modify the PLL multipliers\n    //\n    if(imult != ClkCfgRegs.SYSPLLMULT.bit.IMULT ||\n       fmult != ClkCfgRegs.SYSPLLMULT.bit.FMULT||\n       odiv != ClkCfgRegs.SYSPLLMULT.bit.ODIV)\n    {\n        //\n        // Bypass PLL and set dividers to /1\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = 0;\n\n        //\n        // Evaluate PLL multipliers\n        //\n        temp_syspllmult = (((Uint32)odiv << 16U) | (fmult << 8U) | imult);\n\n        //\n        // Loop to retry locking the PLL should the DCC module indicate\n        // that it was not successful.\n        //\n        for(retries = 0; (retries < MW_PLL_RETRIES); retries++)\n        {\n            //\n            // Bypass PLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n            //\n            // Program PLL multipliers\n            //\n            ClkCfgRegs.SYSPLLMULT.all = temp_syspllmult;\n\n            //\n            // Enable SYSPLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 1;\n\n            timeout = MW_PLL_LOCK_TIMEOUT;\n            pllLockStatus = ClkCfgRegs.SYSPLLSTS.bit.LOCKS;\n\n            //\n            // Wait for the SYSPLL lock\n            //\n            while((pllLockStatus != 1) && (timeout != 0U))\n            {\n                pllLockStatus = ClkCfgRegs.SYSPLLSTS.bit.LOCKS;\n                timeout--;\n            }\n\n            EDIS;\n\n            status = MW_IsPLLValid(clock_source, imult, fmult, odiv);\n\n            //\n            // Check DCC Status, if no error break the loop\n            //\n            if(status)\n            {\n                break;\n            }\n        }\n    }\n    else\n    {\n        status = true;\n    }\n\n    if(status)\n    {\n        EALLOW;\n        //\n        // Set divider to produce slower output frequency to limit current increase\n        //\n        if(divsel != PLLCLK_BY_126)\n        {\n            ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel + 1;\n        }\n        else\n        {\n            ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n        }\n\n        //\n        // Enable PLLSYSCLK is fed from system PLL clock\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n        //\n        // Small 100 cycle delay\n        //\n        asm(\" RPT #100 || NOP\");\n\n        //\n        // Set the divider to user value\n        //\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n        EDIS;\n    }\n}\n"},{"name":"c28004xSchedulerTimer0.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"#include <stdbool.h>\n\n#include \"f28004x_device.h\"\n#include \"f28004x_cputimer.h\"\n#include \"f28004x_cputimervars.h\"\n#include \"MW_c28xx_pie.h\"\n\nextern void rt_OneStep(void);\n\ninterrupt void TINT0_isr(void)\n{\n      #ifdef PIEMASK0\n        volatile unsigned int PIEIER1_stack_save = PieCtrlRegs.PIEIER1.all;\n      #endif\n      #ifdef PIEMASK1\n        volatile unsigned int PIEIER2_stack_save  = PieCtrlRegs.PIEIER2.all;\n      #endif\n      #ifdef PIEMASK2\n        volatile unsigned int PIEIER3_stack_save  = PieCtrlRegs.PIEIER3.all;\n      #endif\n      #ifdef PIEMASK3\n        volatile unsigned int PIEIER4_stack_save  = PieCtrlRegs.PIEIER4.all;\n      #endif\n      #ifdef PIEMASK4\n        volatile unsigned int PIEIER5_stack_save  = PieCtrlRegs.PIEIER5.all;\n      #endif\n      #ifdef PIEMASK5\n        volatile unsigned int PIEIER6_stack_save  = PieCtrlRegs.PIEIER6.all;\n      #endif\n      #ifdef PIEMASK6\n        volatile unsigned int PIEIER7_stack_save  = PieCtrlRegs.PIEIER7.all;\n      #endif\n      #ifdef PIEMASK7\n        volatile unsigned int PIEIER8_stack_save  = PieCtrlRegs.PIEIER8.all;\n      #endif\n      #ifdef PIEMASK8\n        volatile unsigned int PIEIER9_stack_save  = PieCtrlRegs.PIEIER9.all;\n      #endif\n      #ifdef PIEMASK9\n        volatile unsigned int PIEIER10_stack_save = PieCtrlRegs.PIEIER10.all;\n      #endif\n      #ifdef PIEMASK10\n        volatile unsigned int PIEIER11_stack_save = PieCtrlRegs.PIEIER11.all;\n      #endif\n      #ifdef PIEMASK11\n        volatile unsigned int PIEIER12_stack_save = PieCtrlRegs.PIEIER12.all;\n      #endif\n\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all &= ~PIEMASK0;      /* disable group1 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all &= ~PIEMASK1;      /* disable group2 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all &= ~PIEMASK2;      /* disable group3 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all &= ~PIEMASK3;      /* disable group4 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all &= ~PIEMASK4;      /* disable group5 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all &= ~PIEMASK5;      /* disable group6 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all &= ~PIEMASK6;      /* disable group7 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all &= ~PIEMASK7;      /* disable group8 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all &= ~PIEMASK8;      /* disable group9 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all &= ~PIEMASK9;     /* disable group10 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all &= ~PIEMASK10;    /* disable group11 lower/equal priority interrupts */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all &= ~PIEMASK11;    /* disable group12 lower/equal priority interrupts */\n      #endif\n\n      asm(\" RPT #5 || NOP\");               /* wait 5 cycles */\n      IFR &= ~IFRMASK;                           /* eventually disable lower/equal priority pending interrupts */\n      PieCtrlRegs.PIEACK.all = IFRMASK;          /* ACK to allow other interrupts from the same group to fire */\n      IER |= 1;\n      EINT;                                /* global interrupt enable */\n      rt_OneStep();\n      DINT;                                /* disable global interrupts during context switch, CPU will enable global interrupts after exiting ISR */\n      #ifdef PIEMASK0\n        PieCtrlRegs.PIEIER1.all = PIEIER1_stack_save;/*restore PIEIER register that was modified */\n      #endif  \n      #ifdef PIEMASK1\n        PieCtrlRegs.PIEIER2.all = PIEIER2_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK2\n        PieCtrlRegs.PIEIER3.all = PIEIER3_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK3\n        PieCtrlRegs.PIEIER4.all = PIEIER4_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK4\n        PieCtrlRegs.PIEIER5.all = PIEIER5_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK5\n        PieCtrlRegs.PIEIER6.all = PIEIER6_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK6\n        PieCtrlRegs.PIEIER7.all = PIEIER7_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK7\n        PieCtrlRegs.PIEIER8.all = PIEIER8_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK8\n        PieCtrlRegs.PIEIER9.all = PIEIER9_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK9\n        PieCtrlRegs.PIEIER10.all= PIEIER10_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK10\n        PieCtrlRegs.PIEIER11.all= PIEIER11_stack_save;/*restore PIEIER register that was modified */\n      #endif\n      #ifdef PIEMASK11\n        PieCtrlRegs.PIEIER12.all= PIEIER12_stack_save;/*restore PIEIER register that was modified */\n      #endif\n}\n\nvoid configureTimer0(float baseRate, float systemClock)\n{\n    \n    /* InitCpuTimers() - CPU Timers are initialized in \n     * MW_c28xx_board.c in the generated code.\n     */\n\n\t/* Configure CPU-Timer 0 to interrupt every base rate. */\n\t/* Parameters:  Timer Pointer, CPU Freq in MHz, Period in usec. */\n\tConfigCpuTimer(&CpuTimer0, systemClock, baseRate * 1000000);\n\tStartCpuTimer0();\n\n\tEALLOW;\n\tPieVectTable.TIMER0_INT = &TINT0_isr;     /* Hook interrupt to the ISR*/\n\tEDIS;\n\n\tPieCtrlRegs.PIEIER1.bit.INTx7 = 1;   /* Enable interrupt TINT0 */\n\tIER |= M_INT1;\n}\n\nvoid enableTimer0Interrupt(void)\n{\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n\tPieCtrlRegs.PIEIER1.all |= (1 << 6); /* Enable PIER bit for timer 0 */\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n}\n\nbool disableTimer0Interrupt(void)\n{\n    bool isrEnabled = false;\n\tasm(\" SETC INTM\"); /* Disable Interrupt Global Enable Bit - set it to 1 */\n    isrEnabled = PieCtrlRegs.PIEIER1.all & (1 << 6) ;\n\tPieCtrlRegs.PIEIER1.all &= ~(1 << 6); /* Disable PIER bit for timer 0 */\n\tasm(\" RPT #5 || NOP\");\n\tIFR &= 0xFFFE;\n\tPieCtrlRegs.PIEACK.all = 0x1;\n\tasm(\" CLRC INTM\"); /* Enable Interrupt Global Enable Bit - set it to 0 */\n    return isrEnabled;\n}\n\nvoid restoreTimer0Interrupt(bool isrStatus){\n    if(isrStatus)\n        enableTimer0Interrupt();\n    else\n        disableTimer0Interrupt();\n}\n"},{"name":"clb.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\driverlib\\f28004x\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   clb.c\n//\n// TITLE:  C28x CLB driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"clb.h\"\n\n//*****************************************************************************\n//\n// CLB_configCounterLoadMatch\n//\n//*****************************************************************************\nvoid CLB_configCounterLoadMatch(uint32_t base, CLB_Counters counterID,\n                               uint32_t load, uint32_t match1, uint32_t match2)\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    EALLOW;\n    switch(counterID)\n    {\n        case CLB_CTR0:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_0_MATCH2, match2);\n            break;\n\n        case CLB_CTR1:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_1_MATCH2, match2);\n            break;\n\n        case CLB_CTR2:\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_LOAD, load);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH1, match1);\n            CLB_writeInterface(base, CLB_ADDR_COUNTER_2_MATCH2, match2);\n            break;\n\n        default:\n            //\n            // Invalid counterID value\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// CLB_clearFIFOs\n//\n//*****************************************************************************\nvoid CLB_clearFIFOs(uint32_t base)\n{\n    uint16_t i;\n\n    ASSERT(CLB_isBaseValid(base));\n\n    for(i = 0U; i < CLB_FIFO_SIZE; i++)\n    {\n        HWREG(base + CLB_DATAEXCH + CLB_O_PULL(i)) = 0U;\n    }\n\n    HWREG(base + CLB_LOGICCTL + CLB_O_BUF_PTR) = 0U;\n}\n\n//*****************************************************************************\n//\n// CLB_writeFIFOs\n//\n//*****************************************************************************\nvoid CLB_writeFIFOs(uint32_t base , const uint32_t pullData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Clear the FIFO and pointer\n    //\n    CLB_clearFIFOs(base);\n\n    //\n    // Write data into the FIFO.\n    //\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(0)) = pullData[0U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(1)) = pullData[1U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(2)) = pullData[2U];\n    HWREG(base + CLB_DATAEXCH + CLB_O_PULL(3)) = pullData[3U];\n}\n\n//*****************************************************************************\n//\n// CLB_readFIFOs\n//\n//*****************************************************************************\nvoid CLB_readFIFOs(uint32_t base , uint32_t pushData[])\n{\n    ASSERT(CLB_isBaseValid(base));\n\n    //\n    // Read data from the FIFO.\n    //\n    pushData[0U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(0)) ;\n    pushData[1U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(1)) ;\n    pushData[2U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(2)) ;\n    pushData[3U] = HWREG(base + CLB_DATAEXCH + CLB_O_PUSH(3)) ;\n}\n\n\n"},{"name":"dma.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\driverlib\\f28004x\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   dma.c\n//\n// TITLE:  C28x DMA driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"dma.h\"\n\n//*****************************************************************************\n//\n// DMA_configAddresses\n//\n//*****************************************************************************\nvoid DMA_configAddresses(uint32_t base, const void *destAddr,\n                         const void *srcAddr)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up SOURCE address.\n    //\n    HWREG(base + DMA_O_SRC_BEG_ADDR_SHADOW) = (uint32_t)srcAddr;\n    HWREG(base + DMA_O_SRC_ADDR_SHADOW)     = (uint32_t)srcAddr;\n\n    //\n    // Set up DESTINATION address.\n    //\n    HWREG(base + DMA_O_DST_BEG_ADDR_SHADOW) = (uint32_t)destAddr;\n    HWREG(base + DMA_O_DST_ADDR_SHADOW)     = (uint32_t)destAddr;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configBurst\n//\n//*****************************************************************************\nvoid DMA_configBurst(uint32_t base, uint16_t size, int16_t srcStep,\n                     int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((size >= 1U) || (size <= 32U));\n\n    EALLOW;\n\n    //\n    // Set up BURST registers.\n    //\n    HWREGH(base + DMA_O_BURST_SIZE)     = size - 1U;\n    HWREGH(base + DMA_O_SRC_BURST_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_BURST_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configTransfer\n//\n//*****************************************************************************\nvoid DMA_configTransfer(uint32_t base, uint32_t transferSize, int16_t srcStep,\n                        int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT(transferSize <= 0x10000);\n\n    EALLOW;\n\n    //\n    // Set up TRANSFER registers.\n    //\n    HWREGH(base + DMA_O_TRANSFER_SIZE)     = (uint16_t)(transferSize - 1U);\n    HWREGH(base + DMA_O_SRC_TRANSFER_STEP) = srcStep;\n    HWREGH(base + DMA_O_DST_TRANSFER_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configWrap\n//\n//*****************************************************************************\nvoid DMA_configWrap(uint32_t base, uint32_t srcWrapSize, int16_t srcStep,\n                    uint32_t destWrapSize, int16_t destStep)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n    ASSERT((srcWrapSize <= 0x10000) || (destWrapSize <= 0x10000));\n\n    EALLOW;\n\n    //\n    // Set up WRAP registers.\n    //\n    HWREGH(base + DMA_O_SRC_WRAP_SIZE) = (uint16_t)(srcWrapSize - 1U);\n    HWREGH(base + DMA_O_SRC_WRAP_STEP) = srcStep;\n\n    HWREGH(base + DMA_O_DST_WRAP_SIZE) = (uint16_t)(destWrapSize - 1U);\n    HWREGH(base + DMA_O_DST_WRAP_STEP) = destStep;\n\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// DMA_configMode\n//\n//*****************************************************************************\nvoid DMA_configMode(uint32_t base, DMA_Trigger trigger, uint32_t config)\n{\n    //\n    // Check the arguments.\n    //\n    ASSERT(DMA_isBaseValid(base));\n\n    EALLOW;\n\n    //\n    // Set up trigger selection in the CMA/CLA trigger source selection\n    // registers. These are considered part of system control.\n    //\n    switch(base)\n    {\n        case DMA_CH1_BASE:\n            //\n            // Channel 1\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH1_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH1_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH1_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH1_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 1U;\n            break;\n\n        case DMA_CH2_BASE:\n            //\n            // Channel 2\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH2_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH2_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH2_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH2_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 2U;\n            break;\n\n        case DMA_CH3_BASE:\n            //\n            // Channel 3\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH3_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH3_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH3_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH3_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 3U;\n            break;\n\n        case DMA_CH4_BASE:\n            //\n            // Channel 4\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL1) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL1_CH4_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL1_CH4_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH4_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH4_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 4U;\n            break;\n\n        case DMA_CH5_BASE:\n            //\n            // Channel 5\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH5_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH5_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH5_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH5_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 5U;\n            break;\n\n        case DMA_CH6_BASE:\n            //\n            // Channel 6\n            //\n            HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) =\n                (HWREG(DMACLASRCSEL_BASE + SYSCTL_O_DMACHSRCSEL2) &\n                 ~((uint32_t)SYSCTL_DMACHSRCSEL2_CH6_M)) |\n                ((uint32_t)trigger << SYSCTL_DMACHSRCSEL2_CH6_S);\n\n            //\n            // Set peripheral interrupt select bits to the channel number.\n            //\n            HWREGH(DMA_CH6_BASE + DMA_O_MODE) =\n               (HWREGH(DMA_CH6_BASE + DMA_O_MODE) & ~DMA_MODE_PERINTSEL_M) | 6U;\n            break;\n\n        default:\n            //\n            // Invalid base.\n            //\n            break;\n    }\n\n    //\n    // Write the configuration to the mode register.\n    //\n    HWREGH(base + DMA_O_MODE) &= ~(DMA_MODE_DATASIZE | DMA_MODE_CONTINUOUS |\n                                   DMA_MODE_ONESHOT);\n    HWREGH(base + DMA_O_MODE) |= config;\n\n    EDIS;\n}\n\n"},{"name":"f28004x_adc.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    f28004x_adc.c\n//\n// TITLE:   F28004x ADC Support Functions.\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"      // Header File Include File\n#include \"f28004x_examples.h\"    // Examples Include File\n\n//\n// SetVREF - Set Vref mode. Function to select reference mode and offset trim.\n// Offset trim for Internal VREF 3.3 is unique.  All other modes use the same\n// offset trim. Also note that when the mode parameter is ADC_EXTERNAL, the\n// ref parameter has no effect.\n//\nvoid SetVREF(int module, int mode, int ref)\n{\n    Uint16 *offset, offval;\n\n    //\n    // Define offset locations from OTP\n    //\n    offset = (Uint16 *)(0x70594 + (module * 6));\n\n    if((mode == ADC_INTERNAL) && (ref == ADC_VREF3P3))\n    {\n        offval = (*offset) >> 8;    // Internal / 1.65v mode offset\n    }\n    else\n    {\n        offval = (*offset) & 0xFF;  // All other modes\n    }\n\n    //\n    // Write offset trim values and configure reference modes\n    //\n    EALLOW;\n    switch(module)\n    {\n        case 0:\n            AdcaRegs.ADCOFFTRIM.bit.OFFTRIM = offval;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFASEL = mode;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFA2P5SEL = ref;\n            break;\n        case 1:\n            AdcbRegs.ADCOFFTRIM.bit.OFFTRIM = offval;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFBSEL = mode;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFB2P5SEL = ref;\n            break;\n        case 2:\n            AdccRegs.ADCOFFTRIM.bit.OFFTRIM = offval;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFCSEL = mode;\n            AnalogSubsysRegs.ANAREFCTL.bit.ANAREFC2P5SEL = ref;\n            break;\n        default:\n            break;\n    }\n    EDIS;\n}\n\n//\n// End of File\n//\n"},{"name":"f28004x_codestartbranch.asm","type":"other","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":";//###########################################################################\n;//\n;// FILE:  f28004x_codestartbranch.asm\n;//\n;// TITLE: Branch for redirecting code execution after boot.\n;//\n;// For these examples, code_start is the first code that is executed after\n;// exiting the boot ROM code.\n;//\n;// The codestart section in the linker cmd file is used to physically place\n;// this code at the correct memory location. This section should be placed\n;// at the location the BOOT ROM will re-direct the code to. For example,\n;// for boot to FLASH this code will be located at 0x80000.\n;//\n;// In addition, the example f28004x projects are setup such that the codegen\n;// entry point is also set to the codestart label. This is done by linker\n;// option -e in the project build options. When the debugger loads the code,\n;// it will automatically set the PC to the \"entry point\" address indicated by\n;// the -e linker option. In this case the debugger is simply assigning the PC,\n;// it is not the same as a full reset of the device.\n;//\n;// The compiler may warn that the entry point for the project is other then\n;//  _c_init00. _c_init00 is the C environment setup and is run before\n;// main() is entered. The codestart code will re-direct the execution\n;// to _c_init00 and thus there is no worry and this warning can be ignored.\n;//\n;//###########################################################################\n;//\n;//\n;// $Copyright:\n;// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;//###########################################################################\n\n***********************************************************************\n\nWD_DISABLE  .set  1    ;set to 1 to disable WD, else set to 0\n\n    .ref _c_int00\n    .global code_start\n\n***********************************************************************\n* Function: codestart section\n*\n* Description: Branch to code starting point\n***********************************************************************\n\n    .sect \"codestart\"\n    .retain\n\ncode_start:\n    .if WD_DISABLE == 1\n        LB wd_disable       ;Branch to watchdog disable code\n    .else\n        LB _c_int00         ;Branch to start of boot._asm in RTS library\n    .endif\n\n;end codestart section\n\n***********************************************************************\n* Function: wd_disable\n*\n* Description: Disables the watchdog timer\n***********************************************************************\n    .if WD_DISABLE == 1\n\n    .text\nwd_disable:\n    SETC OBJMODE        ;Set OBJMODE for 28x object code\n    EALLOW              ;Enable EALLOW protected register access\n    MOVZ DP, #7029h>>6  ;Set data page for WDCR register\n    MOV @7029h, #0068h  ;Set WDDIS bit in WDCR to disable WD\n    EDIS                ;Disable EALLOW protected register access\n    LB _c_int00         ;Branch to start of boot._asm in RTS library\n\n    .endif\n\n;end wd_disable\n\n    .end\n\n;//\n;// End of file.\n;//\n"},{"name":"f28004x_cputimers.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    f28004x_cputimers.c\n//\n// TITLE:   f28004x CPU 32-bit Timers Initialization & Support Functions.\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"      // Headerfile Include File\n#include \"f28004x_examples.h\"    // Examples Include File\n\n//\n// Globals\n//\nstruct CPUTIMER_VARS CpuTimer0;\nstruct CPUTIMER_VARS CpuTimer1;\nstruct CPUTIMER_VARS CpuTimer2;\n\n//\n// InitCpuTimers - This function initializes all three CPU timers\n// to a known state.\n//\nvoid\nInitCpuTimers(void)\n{\n    //\n    // CPU Timer 0\n    // Initialize address pointers to respective timer registers\n    //\n    CpuTimer0.RegsAddr = &CpuTimer0Regs;\n\n    //\n    // Initialize timer period to maximum\n    //\n    CpuTimer0Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT)\n    //\n    CpuTimer0Regs.TPR.all  = 0;\n    CpuTimer0Regs.TPRH.all = 0;\n\n    //\n    // Make sure timer is stopped\n    //\n    CpuTimer0Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value\n    //\n    CpuTimer0Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters\n    //\n    CpuTimer0.InterruptCount = 0;\n\n    //\n    // CPU Timer 1 and 2\n    // Initialize address pointers to respective timer registers\n    //\n    CpuTimer1.RegsAddr = &CpuTimer1Regs;\n    CpuTimer2.RegsAddr = &CpuTimer2Regs;\n\n    //\n    // Initialize timer period to maximum\n    //\n    CpuTimer1Regs.PRD.all  = 0xFFFFFFFF;\n    CpuTimer2Regs.PRD.all  = 0xFFFFFFFF;\n\n    //\n    // Initialize pre-scale counter to divide by 1 (SYSCLKOUT)\n    //\n    CpuTimer1Regs.TPR.all  = 0;\n    CpuTimer1Regs.TPRH.all = 0;\n    CpuTimer2Regs.TPR.all  = 0;\n    CpuTimer2Regs.TPRH.all = 0;\n\n    //\n    // Make sure timers are stopped\n    //\n    CpuTimer1Regs.TCR.bit.TSS = 1;\n    CpuTimer2Regs.TCR.bit.TSS = 1;\n\n    //\n    // Reload all counter register with period value\n    //\n    CpuTimer1Regs.TCR.bit.TRB = 1;\n    CpuTimer2Regs.TCR.bit.TRB = 1;\n\n    //\n    // Reset interrupt counters\n    //\n    CpuTimer1.InterruptCount = 0;\n    CpuTimer2.InterruptCount = 0;\n}\n\n//\n// ConfigCpuTimer - This function initializes the selected timer to the period\n// specified by the \"Freq\" and \"Period\" parameters. The \"Freq\" is entered\n// as \"MHz\" and the \"Period\" in \"uSeconds\". The timer is held in the stopped\n// state after configuration.\n//\nvoid\nConfigCpuTimer(struct CPUTIMER_VARS *Timer, float Freq, float Period)\n{\n    Uint32 temp;\n\n    //\n    // Initialize timer period\n    //\n    Timer->CPUFreqInMHz = Freq;\n    Timer->PeriodInUSec = Period;\n    temp = (long) (Freq * Period);\n    Timer->RegsAddr->PRD.all = temp;\n\n    //\n    // Set pre-scale counter to divide by 1 (SYSCLKOUT)\n    //\n    Timer->RegsAddr->TPR.all  = 0;\n    Timer->RegsAddr->TPRH.all  = 0;\n\n    //\n    // Initialize timer control register\n    //\n\n    //\n    // 1 = Stop timer, 0 = Start/Restart Timer\n    //\n    Timer->RegsAddr->TCR.bit.TSS = 1;\n\n    //\n    // 1 = reload timer\n    //\n    Timer->RegsAddr->TCR.bit.TRB = 1;\n    Timer->RegsAddr->TCR.bit.SOFT = 0;\n\n    //\n    // Timer Free Run Disabled\n    //\n    Timer->RegsAddr->TCR.bit.FREE = 0;\n\n    //\n    // 0 = Disable 1 = Enable Timer Interrupt\n    //\n    Timer->RegsAddr->TCR.bit.TIE = 1;\n\n    //\n    // Reset interrupt counter\n    //\n    Timer->InterruptCount = 0;\n}\n\n//\n// End of File\n//\n\n"},{"name":"f28004x_defaultisr.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   f28004x_defaultisr.c\n//\n// TITLE:  f28004x Device Default Interrupt Service Routines\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"       // F28004x Header File Include File\n#include \"f28004x_examples.h\"     // F28004x Examples Include File\n\n//\n// TIMER1_ISR - CPU Timer 1 Interrupt\n//\n__interrupt void\nTIMER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// TIMER2_ISR - CPU Timer 2 Interrupt\n//\n__interrupt void\nTIMER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DATALOG_ISR - Datalogging Interrupt\n//\n__interrupt void\nDATALOG_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// RTOS_ISR - RTOS Interrupt\n//\n__interrupt void\nRTOS_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EMU_ISR - Emulation Interrupt\n//\n__interrupt void\nEMU_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// NMI_ISR - Non-Maskable Interrupt\n//\n__interrupt void\nNMI_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ILLEGAL_ISR - Illegal Operation Trap\n//\n__interrupt void\nILLEGAL_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER1_ISR - User Defined Trap 1\n//\n__interrupt void\nUSER1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER2_ISR - User Defined Trap 2\n//\n__interrupt void\nUSER2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER3_ISR - User Defined Trap 3\n//\n__interrupt void\nUSER3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER4_ISR - User Defined Trap 4\n//\n__interrupt void\nUSER4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER5_ISR - User Defined Trap 5\n//\n__interrupt void\nUSER5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER6_ISR - User Defined Trap 6\n//\n__interrupt void\nUSER6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER7_ISR - User Defined Trap 7\n//\n__interrupt void\nUSER7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER8_ISR - User Defined Trap 8\n//\n__interrupt void\nUSER8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER9_ISR - User Defined Trap 9\n//\n__interrupt void\nUSER9_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER10_ISR - User Defined Trap 10\n//\n__interrupt void\nUSER10_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER11_ISR - User Defined Trap 11\n//\n__interrupt void\nUSER11_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// USER12_ISR - User Defined Trap 12\n//\n__interrupt void\nUSER12_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCA1_ISR - ADCA Interrupt 1\n//\n__interrupt void\nADCA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCB1_ISR - ADCB Interrupt 1\n//\n__interrupt void\nADCB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCC1_ISR - ADCC Interrupt 1\n//\n__interrupt void\nADCC1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// XINT1_ISR - XINT1 Interrupt\n//\n__interrupt void\nXINT1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// XINT2_ISR - XINT2 Interrupt\n//\n__interrupt void\nXINT2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// TIMER0_ISR - Timer 0 Interrupt\n//\n__interrupt void\nTIMER0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// WAKE_ISR - Halt Wakeup Interrupt\n//\n__interrupt void\nWAKE_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM1_TZ_ISR - ePWM1 Trip Zone Interrupt\n//\n__interrupt void\nEPWM1_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM2_TZ_ISR - ePWM2 Trip Zone Interrupt\n//\n__interrupt void\nEPWM2_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM3_TZ_ISR - ePWM3 Trip Zone Interrupt\n//\n__interrupt void\nEPWM3_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM4_TZ_ISR - ePWM4 Trip Zone Interrupt\n//\n__interrupt void\nEPWM4_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM5_TZ_ISR - ePWM5 Trip Zone Interrupt\n//\n__interrupt void\nEPWM5_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM6_TZ_ISR - ePWM6 Trip Zone Interrupt\n//\n__interrupt void\nEPWM6_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM7_TZ_ISR - ePWM7 Trip Zone Interrupt\n//\n__interrupt void\nEPWM7_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM8_TZ_ISR - ePWM8 Trip Zone Interrupt\n//\n__interrupt void\nEPWM8_TZ_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP2;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM1_ISR - ePWM1 Interrupt\n//\n__interrupt void\nEPWM1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM2_ISR - ePWM2 Interrupt\n//\n__interrupt void\nEPWM2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM3_ISR - ePWM3 Interrupt\n//\n__interrupt void\nEPWM3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM4_ISR - ePWM4 Interrupt\n//\n__interrupt void\nEPWM4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM5_ISR - ePWM5 Interrupt\n//\n__interrupt void\nEPWM5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM6_ISR - ePWM6 Interrupt\n//\n__interrupt void\nEPWM6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM7_ISR - ePWM7 Interrupt\n//\n__interrupt void\nEPWM7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EPWM8_ISR - ePWM8 Interrupt\n//\n__interrupt void\nEPWM8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP1_ISR - eCAP1 Interrupt\n//\n__interrupt void\nECAP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP2_ISR - eCAP2 Interrupt\n//\n__interrupt void\nECAP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP3_ISR - eCAP3 Interrupt\n//\n__interrupt void\nECAP3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP4_ISR - eCAP4 Interrupt\n//\n__interrupt void\nECAP4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP5_ISR - eCAP5 Interrupt\n//\n__interrupt void\nECAP5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP6_ISR - eCAP6 Interrupt\n//\n__interrupt void\nECAP6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP7_ISR - eCAP7 Interrupt\n//\n__interrupt void\nECAP7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP6_2_ISR - eCAP6_2 Interrupt\n//\n__interrupt void\nECAP6_2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ECAP7_2_ISR - eCAP7_2 Interrupt\n//\n__interrupt void\nECAP7_2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP4;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EQEP1_ISR - eQEP1 Interrupt\n//\n__interrupt void\nEQEP1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EQEP2_ISR - eQEP2 Interrupt\n//\n__interrupt void\nEQEP2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SPIA_RX_ISR - SPIA Receive Interrupt\n//\n__interrupt void\nSPIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SPIA_TX_ISR - SPIA Transmit Interrupt\n//\n__interrupt void\nSPIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SPIB_RX_ISR - SPIB Receive Interrupt\n//\n__interrupt void\nSPIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SPIB_TX_ISR - SPIB Transmit Interrupt\n//\n__interrupt void\nSPIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP6;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH1_ISR - DMA Channel 1 Interrupt\n//\n__interrupt void\nDMA_CH1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH2_ISR - DMA Channel 2 Interrupt\n//\n__interrupt void\nDMA_CH2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH3_ISR - DMA Channel 3 Interrupt\n//\n__interrupt void\nDMA_CH3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH4_ISR - DMA Channel 4 Interrupt\n//\n__interrupt void\nDMA_CH4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH5_ISR - DMA Channel 5 Interrupt\n//\n__interrupt void\nDMA_CH5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// DMA_CH6_ISR - DMA Channel 6 Interrupt\n//\n__interrupt void\nDMA_CH6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// I2CA_ISR - I2CA Interrupt 1\n//\n__interrupt void\nI2CA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// I2CA_FIFO_ISR - I2CA Interrupt 2\n//\n__interrupt void\nI2CA_FIFO_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SCIA_RX_ISR - SCIA Receive Interrupt\n//\n__interrupt void\nSCIA_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SCIA_TX_ISR - SCIA Transmit Interrupt\n//\n__interrupt void\nSCIA_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SCIB_RX_ISR - SCIB Receive Interrupt\n//\n__interrupt void\nSCIB_RX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SCIB_TX_ISR - SCIB Transmit Interrupt\n//\n__interrupt void\nSCIB_TX_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CANA0_ISR - CANA Interrupt 0\n//\n__interrupt void\nCANA0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CANA1_ISR - CANA Interrupt 1\n//\n__interrupt void\nCANA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CANB0_ISR - CANB Interrupt 0\n//\n__interrupt void\nCANB0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CANB1_ISR - CANB Interrupt 1\n//\n__interrupt void\nCANB1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP9;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCA_EVT_ISR - ADCA Event Interrupt\n//\n__interrupt void\nADCA_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCA2_ISR - ADCA Interrupt 2\n//\n__interrupt void\nADCA2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCA3_ISR - ADCA Interrupt 3\n//\n__interrupt void\nADCA3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCA4_ISR - ADCA Interrupt 4\n//\n__interrupt void\nADCA4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCB_EVT_ISR - ADCB Event Interrupt\n//\n__interrupt void\nADCB_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCB2_ISR - ADCB Interrupt 2\n//\n__interrupt void\nADCB2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCB3_ISR - ADCB Interrupt 3\n//\n__interrupt void\nADCB3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCB4_ISR - ADCB Interrupt 4\n//\n__interrupt void\nADCB4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_1_ISR - CLA1 Interrupt 1\n//\n__interrupt void\nCLA1_1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_2_ISR - CLA1 Interrupt 2\n//\n__interrupt void\nCLA1_2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_3_ISR - CLA1 Interrupt 3\n//\n__interrupt void\nCLA1_3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_4_ISR - CLA1 Interrupt 4\n//\n__interrupt void\nCLA1_4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_5_ISR - CLA1 Interrupt 5\n//\n__interrupt void\nCLA1_5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_6_ISR - CLA1 Interrupt 6\n//\n__interrupt void\nCLA1_6_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_7_ISR - CLA1 Interrupt 7\n//\n__interrupt void\nCLA1_7_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1_8_ISR - CLA1 Interrupt 8\n//\n__interrupt void\nCLA1_8_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP11;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// XINT3_ISR - XINT3 Interrupt\n//\n__interrupt void\nXINT3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// XINT4_ISR - XINT4 Interrupt\n//\n__interrupt void\nXINT4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// XINT5_ISR - XINT5 Interrupt\n//\n__interrupt void\nXINT5_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FPU_OVERFLOW_ISR - FPU Overflow Interrupt\n//\n__interrupt void\nFPU_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FPU_UNDERFLOW_ISR - FPU Underflow Interrupt\n//\n__interrupt void\nFPU_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SD1_ISR - SDFM1 Interrupt\n//\n__interrupt void\nSD1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SD1DR1_ISR - SDFM1 DR Interrupt 1\n//\n__interrupt void\nSD1DR1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SD1DR2_ISR - SDFM1 DR Interrupt 2\n//\n__interrupt void\nSD1DR2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SD1DR3_ISR - SDFM1 DR Interrupt 3\n//\n__interrupt void\nSD1DR3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SD1DR4_ISR - SDFM1 DR Interrupt 4\n//\n__interrupt void\nSD1DR4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP5;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n\n//\n// FSITXA1_ISR - FSITXA1_ISR Interrupt\n//\n__interrupt void\nFSITXA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FSITXA2_ISR - FSITXA2_ISR Interrupt\n//\n__interrupt void\nFSITXA2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FSIRXA1_ISR - FSIRXA1_ISR Interrupt\n//\n__interrupt void\nFSIRXA1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FSIRXA2_ISR - FSIRXA2_ISR Interrupt\n//\n__interrupt void\nFSIRXA2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA1PROMCRC - CLA1PROMCRC Interrupt\n//\n__interrupt void\nCLA1PROMCRC_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP7;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// LINA_0 - LINA Interrupt 0\n//\n__interrupt void\nLINA_0_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// LINA_1 - LINA Interrupt 1\n//\n__interrupt void\nLINA_1_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// PMBUSA - PMBUSA Interrupt\n//\n__interrupt void\nPMBUSA_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP8;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCC_EVT_ISR - ADCC Event Interrupt\n//\n__interrupt void\nADCC_EVT_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCC2_ISR - ADCC Interrupt 2\n//\n__interrupt void\nADCC2_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCC3_ISR - ADCC Interrupt 3\n//\n__interrupt void\nADCC3_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// ADCC4_ISR - ADCC Interrupt 4\n//\n__interrupt void\nADCC4_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP10;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// RAM_CORRECTABLE_ERROR_ISR - RAM Correctable Error Interrupt\n//\n__interrupt void\nRAM_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// FLASH_CORRECTABLE_ERROR_ISR - Flash Correctable Error Interrupt\n//\n__interrupt void\nFLASH_CORRECTABLE_ERROR_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// RAM_ACCESS_VIOLATION_ISR - RAM Access Violation Interrupt\n//\n__interrupt void\nRAM_ACCESS_VIOLATION_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// SYS_PLL_SLIP_ISR - System PLL Slip Interrupt\n//\n__interrupt void\nSYS_PLL_SLIP_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA_OVERFLOW_ISR - CLA Overflow Interrupt\n//\n__interrupt void\nCLA_OVERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// CLA_UNDERFLOW_ISR - CLA Underflow Interrupt\n//\n__interrupt void\nCLA_UNDERFLOW_ISR(void)\n{\n    //\n    // Insert ISR Code here\n    //\n\n    //\n    // To receive more interrupts from this PIE group,\n    // acknowledge this interrupt.\n    //\n    // PieCtrlRegs.PIEACK.all = PIEACK_GROUP12;\n\n    //\n    // Next two lines for debug only to halt the processor here\n    // Remove after inserting ISR Code\n    //\n    ESTOP0;\n    for(;;);\n}\n\n//\n// Catch-all Default ISRs\n//\n\n//\n// PIE_RESERVED_ISR - Reserved ISR\n//\n__interrupt void\nPIE_RESERVED_ISR(void)\n{\n    ESTOP0;\n    for(;;);\n}\n\n//\n// EMPTY_ISR - Only does a return\n//\n__interrupt void\nEMPTY_ISR(void)\n{\n\n}\n\n//\n// NOTUSED_ISR - Unused ISR\n//\n__interrupt void\nNOTUSED_ISR(void)\n{\n    ESTOP0;\n    for(;;);\n}\n\n//\n// End of File\n//\n\n"},{"name":"f28004x_globalvariabledefs.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\headers\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:    f28004x_globalvariabledefs.c\n//\n// TITLE:   f28004x Global Variables and Data Section Pragmas.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"f28004x_device.h\"     // f28004x Headerfile Include File\n\n//---------------------------------------------------------------------------\n// Define Global Peripheral Variables:\n//\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AccessProtectionRegsFile\")\n#else\n#pragma DATA_SECTION(AccessProtectionRegs,\"AccessProtectionRegsFile\");\n#endif\nvolatile struct ACCESS_PROTECTION_REGS AccessProtectionRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaRegs,\"AdcaRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbRegs,\"AdcbRegsFile\");\n#endif\nvolatile struct ADC_REGS AdcbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccRegsFile\")\n#else\n#pragma DATA_SECTION(AdccRegs,\"AdccRegsFile\");\n#endif\nvolatile struct ADC_REGS AdccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcaResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcaResultRegs,\"AdcaResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcaResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdcbResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdcbResultRegs,\"AdcbResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdcbResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AdccResultRegsFile\")\n#else\n#pragma DATA_SECTION(AdccResultRegs,\"AdccResultRegsFile\");\n#endif\nvolatile struct ADC_RESULT_REGS AdccResultRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"AnalogSubsysRegsFile\")\n#else\n#pragma DATA_SECTION(AnalogSubsysRegs,\"AnalogSubsysRegsFile\");\n#endif\nvolatile struct ANALOG_SUBSYS_REGS AnalogSubsysRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanaRegsFile\")\n#else\n#pragma DATA_SECTION(CanaRegs,\"CanaRegsFile\");\n#endif\nvolatile struct CAN_REGS CanaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CanbRegsFile\")\n#else\n#pragma DATA_SECTION(CanbRegs,\"CanbRegsFile\");\n#endif\nvolatile struct CAN_REGS CanbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClaPromCrc0RegsFile\")\n#else\n#pragma DATA_SECTION(ClaPromCrc0Regs,\"ClaPromCrc0RegsFile\");\n#endif\nvolatile struct CLA_PROM_CRC32_REGS ClaPromCrc0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cla1RegsFile\")\n#else\n#pragma DATA_SECTION(Cla1Regs,\"Cla1RegsFile\");\n#endif\nvolatile struct CLA_REGS Cla1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1DataExchRegs,\"Clb1DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb1DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2DataExchRegs,\"Clb2DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb2DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3DataExchRegs,\"Clb3DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb3DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4DataExchRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4DataExchRegs,\"Clb4DataExchRegsFile\");\n#endif\nvolatile struct CLB_DATA_EXCHANGE_REGS Clb4DataExchRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCfgRegs,\"Clb1LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb1LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCfgRegs,\"Clb2LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb2LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCfgRegs,\"Clb3LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb3LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCfgRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCfgRegs,\"Clb4LogicCfgRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONFIG_REGS Clb4LogicCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb1LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb1LogicCtrlRegs,\"Clb1LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb1LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb2LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb2LogicCtrlRegs,\"Clb2LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb2LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb3LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb3LogicCtrlRegs,\"Clb3LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb3LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Clb4LogicCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Clb4LogicCtrlRegs,\"Clb4LogicCtrlRegsFile\");\n#endif\nvolatile struct CLB_LOGIC_CONTROL_REGS Clb4LogicCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CLBXbarRegsFile\")\n#else\n#pragma DATA_SECTION(CLBXbarRegs,\"CLBXbarRegsFile\");\n#endif\nvolatile struct CLB_XBAR_REGS CLBXbarRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ClkCfgRegsFile\")\n#else\n#pragma DATA_SECTION(ClkCfgRegs,\"ClkCfgRegsFile\");\n#endif\nvolatile struct CLK_CFG_REGS ClkCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss1RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss1Regs,\"Cmpss1RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss2RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss2Regs,\"Cmpss2RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss3RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss3Regs,\"Cmpss3RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss4RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss4Regs,\"Cmpss4RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss5RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss5Regs,\"Cmpss5RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss6RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss6Regs,\"Cmpss6RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Cmpss7RegsFile\")\n#else\n#pragma DATA_SECTION(Cmpss7Regs,\"Cmpss7RegsFile\");\n#endif\nvolatile struct CMPSS_REGS Cmpss7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer0RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer0Regs,\"CpuTimer0RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer1RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer1Regs,\"CpuTimer1RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuTimer2RegsFile\")\n#else\n#pragma DATA_SECTION(CpuTimer2Regs,\"CpuTimer2RegsFile\");\n#endif\nvolatile struct CPUTIMER_REGS CpuTimer2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"CpuSysRegsFile\")\n#else\n#pragma DATA_SECTION(CpuSysRegs,\"CpuSysRegsFile\");\n#endif\nvolatile struct CPU_SYS_REGS CpuSysRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacaRegsFile\")\n#else\n#pragma DATA_SECTION(DacaRegs,\"DacaRegsFile\");\n#endif\nvolatile struct DAC_REGS DacaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DacbRegsFile\")\n#else\n#pragma DATA_SECTION(DacbRegs,\"DacbRegsFile\");\n#endif\nvolatile struct DAC_REGS DacbRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Dcc0RegsFile\")\n#else\n#pragma DATA_SECTION(Dcc0Regs,\"Dcc0RegsFile\");\n#endif\nvolatile struct DCC_REGS Dcc0Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmBank0Z1RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmBank0Z1Regs,\"DcsmBank0Z1RegsFile\");\n#endif\nvolatile struct DCSM_BANK0_Z1_REGS DcsmBank0Z1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmBank0Z2RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmBank0Z2Regs,\"DcsmBank0Z2RegsFile\");\n#endif\nvolatile struct DCSM_BANK0_Z2_REGS DcsmBank0Z2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmBank1Z1RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmBank1Z1Regs,\"DcsmBank1Z1RegsFile\");\n#endif\nvolatile struct DCSM_BANK1_Z1_REGS DcsmBank1Z1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmBank1Z2RegsFile\")\n#else\n#pragma DATA_SECTION(DcsmBank1Z2Regs,\"DcsmBank1Z2RegsFile\");\n#endif\nvolatile struct DCSM_BANK1_Z2_REGS DcsmBank1Z2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DcsmCommonRegsFile\")\n#else\n#pragma DATA_SECTION(DcsmCommonRegs,\"DcsmCommonRegsFile\");\n#endif\nvolatile struct DCSM_COMMON_REGS DcsmCommonRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DevCfgRegsFile\")\n#else\n#pragma DATA_SECTION(DevCfgRegs,\"DevCfgRegsFile\");\n#endif\nvolatile struct DEV_CFG_REGS DevCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaClaSrcSelRegsFile\")\n#else\n#pragma DATA_SECTION(DmaClaSrcSelRegs,\"DmaClaSrcSelRegsFile\");\n#endif\nvolatile struct DMA_CLA_SRC_SEL_REGS DmaClaSrcSelRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"DmaRegsFile\")\n#else\n#pragma DATA_SECTION(DmaRegs,\"DmaRegsFile\");\n#endif\nvolatile struct DMA_REGS DmaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap1RegsFile\")\n#else\n#pragma DATA_SECTION(ECap1Regs,\"ECap1RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap2RegsFile\")\n#else\n#pragma DATA_SECTION(ECap2Regs,\"ECap2RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap3RegsFile\")\n#else\n#pragma DATA_SECTION(ECap3Regs,\"ECap3RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap4RegsFile\")\n#else\n#pragma DATA_SECTION(ECap4Regs,\"ECap4RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap5RegsFile\")\n#else\n#pragma DATA_SECTION(ECap5Regs,\"ECap5RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap6RegsFile\")\n#else\n#pragma DATA_SECTION(ECap6Regs,\"ECap6RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ECap7RegsFile\")\n#else\n#pragma DATA_SECTION(ECap7Regs,\"ECap7RegsFile\");\n#endif\nvolatile struct ECAP_REGS ECap7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm1RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm1Regs,\"EPwm1RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm2RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm2Regs,\"EPwm2RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm3RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm3Regs,\"EPwm3RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm4RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm4Regs,\"EPwm4RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm5RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm5Regs,\"EPwm5RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm6RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm6Regs,\"EPwm6RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm7RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm7Regs,\"EPwm7RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwm8RegsFile\")\n#else\n#pragma DATA_SECTION(EPwm8Regs,\"EPwm8RegsFile\");\n#endif\nvolatile struct EPWM_REGS EPwm8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EPwmXbarRegsFile\")\n#else\n#pragma DATA_SECTION(EPwmXbarRegs,\"EPwmXbarRegsFile\");\n#endif\nvolatile struct EPWM_XBAR_REGS EPwmXbarRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep1RegsFile\")\n#else\n#pragma DATA_SECTION(EQep1Regs,\"EQep1RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EQep2RegsFile\")\n#else\n#pragma DATA_SECTION(EQep2Regs,\"EQep2RegsFile\");\n#endif\nvolatile struct EQEP_REGS EQep2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradCounter1RegsFile\")\n#else\n#pragma DATA_SECTION(EradCounter1Regs,\"EradCounter1RegsFile\");\n#endif\nvolatile struct ERAD_COUNTER_REGS EradCounter1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradCounter2RegsFile\")\n#else\n#pragma DATA_SECTION(EradCounter2Regs,\"EradCounter2RegsFile\");\n#endif\nvolatile struct ERAD_COUNTER_REGS EradCounter2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradCounter3RegsFile\")\n#else\n#pragma DATA_SECTION(EradCounter3Regs,\"EradCounter3RegsFile\");\n#endif\nvolatile struct ERAD_COUNTER_REGS EradCounter3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradCounter4RegsFile\")\n#else\n#pragma DATA_SECTION(EradCounter4Regs,\"EradCounter4RegsFile\");\n#endif\nvolatile struct ERAD_COUNTER_REGS EradCounter4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradGlobalRegsFile\")\n#else\n#pragma DATA_SECTION(EradGlobalRegs,\"EradGlobalRegsFile\");\n#endif\nvolatile struct ERAD_GLOBAL_REGS EradGlobalRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP1RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP1Regs,\"EradHWBP1RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP2RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP2Regs,\"EradHWBP2RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP3RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP3Regs,\"EradHWBP3RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP4RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP4Regs,\"EradHWBP4RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP5RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP5Regs,\"EradHWBP5RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP6RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP6Regs,\"EradHWBP6RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP7RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP7Regs,\"EradHWBP7RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"EradHWBP8RegsFile\")\n#else\n#pragma DATA_SECTION(EradHWBP8Regs,\"EradHWBP8RegsFile\");\n#endif\nvolatile struct ERAD_HWBP_REGS EradHWBP8Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0CtrlRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0CtrlRegs,\"Flash0CtrlRegsFile\");\n#endif\nvolatile struct FLASH_CTRL_REGS Flash0CtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Flash0EccRegsFile\")\n#else\n#pragma DATA_SECTION(Flash0EccRegs,\"Flash0EccRegsFile\");\n#endif\nvolatile struct FLASH_ECC_REGS Flash0EccRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"FsiRxaRegsFile\")\n#else\n#pragma DATA_SECTION(FsiRxaRegs,\"FsiRxaRegsFile\");\n#endif\nvolatile struct FSI_RX_REGS FsiRxaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"FsiTxaRegsFile\")\n#else\n#pragma DATA_SECTION(FsiTxaRegs,\"FsiTxaRegsFile\");\n#endif\nvolatile struct FSI_TX_REGS FsiTxaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(GpioCtrlRegs,\"GpioCtrlRegsFile\");\n#endif\nvolatile struct GPIO_CTRL_REGS GpioCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"GpioDataRegsFile\")\n#else\n#pragma DATA_SECTION(GpioDataRegs,\"GpioDataRegsFile\");\n#endif\nvolatile struct GPIO_DATA_REGS GpioDataRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"HRCap6RegsFile\")\n#else\n#pragma DATA_SECTION(HRCap6Regs,\"HRCap6RegsFile\");\n#endif\nvolatile struct HRCAP_REGS HRCap6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"HRCap7RegsFile\")\n#else\n#pragma DATA_SECTION(HRCap7Regs,\"HRCap7RegsFile\");\n#endif\nvolatile struct HRCAP_REGS HRCap7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"I2caRegsFile\")\n#else\n#pragma DATA_SECTION(I2caRegs,\"I2caRegsFile\");\n#endif\nvolatile struct I2C_REGS I2caRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"InputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(InputXbarRegs,\"InputXbarRegsFile\");\n#endif\nvolatile struct INPUT_XBAR_REGS InputXbarRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"LinaRegsFile\")\n#else\n#pragma DATA_SECTION(LinaRegs,\"LinaRegsFile\");\n#endif\nvolatile struct LIN_REGS LinaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemoryErrorRegsFile\")\n#else\n#pragma DATA_SECTION(MemoryErrorRegs,\"MemoryErrorRegsFile\");\n#endif\nvolatile struct MEMORY_ERROR_REGS MemoryErrorRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"MemCfgRegsFile\")\n#else\n#pragma DATA_SECTION(MemCfgRegs,\"MemCfgRegsFile\");\n#endif\nvolatile struct MEM_CFG_REGS MemCfgRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"NmiIntruptRegsFile\")\n#else\n#pragma DATA_SECTION(NmiIntruptRegs,\"NmiIntruptRegsFile\");\n#endif\nvolatile struct NMI_INTRUPT_REGS NmiIntruptRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"OutputXbarRegsFile\")\n#else\n#pragma DATA_SECTION(OutputXbarRegs,\"OutputXbarRegsFile\");\n#endif\nvolatile struct OUTPUT_XBAR_REGS OutputXbarRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SysPeriphAcRegsFile\")\n#else\n#pragma DATA_SECTION(SysPeriphAcRegs,\"SysPeriphAcRegsFile\");\n#endif\nvolatile struct PERIPH_AC_REGS SysPeriphAcRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga1RegsFile\")\n#else\n#pragma DATA_SECTION(Pga1Regs,\"Pga1RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga2RegsFile\")\n#else\n#pragma DATA_SECTION(Pga2Regs,\"Pga2RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga2Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga3RegsFile\")\n#else\n#pragma DATA_SECTION(Pga3Regs,\"Pga3RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga3Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga4RegsFile\")\n#else\n#pragma DATA_SECTION(Pga4Regs,\"Pga4RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga4Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga5RegsFile\")\n#else\n#pragma DATA_SECTION(Pga5Regs,\"Pga5RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga5Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga6RegsFile\")\n#else\n#pragma DATA_SECTION(Pga6Regs,\"Pga6RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga6Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Pga7RegsFile\")\n#else\n#pragma DATA_SECTION(Pga7Regs,\"Pga7RegsFile\");\n#endif\nvolatile struct PGA_REGS Pga7Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieCtrlRegsFile\")\n#else\n#pragma DATA_SECTION(PieCtrlRegs,\"PieCtrlRegsFile\");\n#endif\nvolatile struct PIE_CTRL_REGS PieCtrlRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PieVectTableFile\")\n#else\n#pragma DATA_SECTION(PieVectTable,\"PieVectTableFile\");\n#endif\nvolatile struct PIE_VECT_TABLE PieVectTable;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"PmbusaRegsFile\")\n#else\n#pragma DATA_SECTION(PmbusaRegs,\"PmbusaRegsFile\");\n#endif\nvolatile struct PMBUS_REGS PmbusaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SciaRegsFile\")\n#else\n#pragma DATA_SECTION(SciaRegs,\"SciaRegsFile\");\n#endif\nvolatile struct SCI_REGS SciaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"ScibRegsFile\")\n#else\n#pragma DATA_SECTION(ScibRegs,\"ScibRegsFile\");\n#endif\nvolatile struct SCI_REGS ScibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"Sdfm1RegsFile\")\n#else\n#pragma DATA_SECTION(Sdfm1Regs,\"Sdfm1RegsFile\");\n#endif\nvolatile struct SDFM_REGS Sdfm1Regs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpiaRegsFile\")\n#else\n#pragma DATA_SECTION(SpiaRegs,\"SpiaRegsFile\");\n#endif\nvolatile struct SPI_REGS SpiaRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SpibRegsFile\")\n#else\n#pragma DATA_SECTION(SpibRegs,\"SpibRegsFile\");\n#endif\nvolatile struct SPI_REGS SpibRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"SyncSocRegsFile\")\n#else\n#pragma DATA_SECTION(SyncSocRegs,\"SyncSocRegsFile\");\n#endif\nvolatile struct SYNC_SOC_REGS SyncSocRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"WdRegsFile\")\n#else\n#pragma DATA_SECTION(WdRegs,\"WdRegsFile\");\n#endif\nvolatile struct WD_REGS WdRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XbarRegsFile\")\n#else\n#pragma DATA_SECTION(XbarRegs,\"XbarRegsFile\");\n#endif\nvolatile struct XBAR_REGS XbarRegs;\n\n//----------------------------------------\n#ifdef __cplusplus\n#pragma DATA_SECTION(\"XintRegsFile\")\n#else\n#pragma DATA_SECTION(XintRegs,\"XintRegsFile\");\n#endif\nvolatile struct XINT_REGS XintRegs;\n\n\n\n//===========================================================================\n// End of file.\n//===========================================================================\n\n\n"},{"name":"f28004x_gpio.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   f28004x_gpio.c\n//\n// TITLE:  f28004x GPIO module support functions\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"\n#include \"f28004x_examples.h\"\n\n//\n// Low-level functions for GPIO configuration\n//\n\n//\n// InitGpio - Sets all pins to be muxed to GPIO in input mode with pull-ups\n// enabled.Also resets CPU control to CPU1 and disables open drain\n// and polarity inversion and sets the qualification to synchronous.\n// Also unlocks all GPIOs. Only one CPU should call this function.\n//\nvoid\nInitGpio()\n{\n    volatile Uint32 *gpioBaseAddr;\n    Uint16 regOffset;\n\n    //\n    // Disable pin locks\n    //\n    EALLOW;\n    GpioCtrlRegs.GPALOCK.all = 0x00000000;\n    GpioCtrlRegs.GPBLOCK.all = 0x00000000;\n    GpioCtrlRegs.GPHLOCK.all = 0x00000000;\n\n    //\n    // Fill all registers with zeros. Writing to each register separately\n    // for three GPIO modules would make this function *very* long.\n    // Fortunately, we'd be writing them all with zeros anyway,\n    // so this saves a lot of space.\n    //\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioCtrlRegs)/2; regOffset++)\n    {\n        //\n        // Must avoid enabling pull-ups on all pins. GPyPUD is offset\n        // 0x0C in each register group of 0x40 words. Since this is a\n        // 32-bit pointer, the addresses must be divided by 2.\n        //\n        // Also, to avoid changing pin muxing of the emulator pins to regular\n        // GPIOs, skip GPBMUX1 (0x46) and GPBGMUX1 (0x60).\n        //\n        if ((regOffset % (0x40/2) != (0x0C/2)) && (regOffset != (0x46/2)) &&\n            (regOffset != (0x60/2)))\n        {\n            gpioBaseAddr[regOffset] = 0x00000000;\n        }\n    }\n\n    gpioBaseAddr = (Uint32 *)&GpioDataRegs;\n    for (regOffset = 0; regOffset < sizeof(GpioDataRegs)/2; regOffset++)\n    {\n        gpioBaseAddr[regOffset] = 0x00000000;\n    }\n\n    EDIS;\n}\n\n//\n// GPIO_SetupPinMux - Set the peripheral muxing for the specified pin.\n// The appropriate parameters can be found in the pinout spreadsheet.\n//\nvoid\nGPIO_SetupPinMux(Uint16 gpioNumber, Uint16 cpu, Uint16 muxPosition)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *mux, *gmux, *csel;\n    Uint16 pin32, pin16, pin8;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pin8 = gpioNumber % 8;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    //\n    // Sanity check for valid cpu and peripheral values\n    //\n    if (cpu > GPIO_MUX_CPU1CLA || muxPosition > 0xF)\n    {\n        return;\n    }\n\n    //\n    // Create pointers to the appropriate registers. This is a workaround\n    // for the way GPIO registers are defined. The standard definition\n    // in the header file makes it very easy to do named accesses of one\n    // register or bit, but hard to do arbitrary numerical accesses. It's\n    // easier to have an array of GPIO modules with identical registers,\n    // including arrays for multi-register groups like GPyCSEL1-4. But\n    // the header file doesn't define anything we can turn into an array,\n    // so manual pointer arithmetic is used instead.\n    //\n    mux = gpioBaseAddr + GPYMUX + pin32/16;\n    gmux = gpioBaseAddr + GPYGMUX + pin32/16;\n    csel = gpioBaseAddr + GPYCSEL + pin32/8;\n\n    //\n    // Now for the actual function\n    //\n    EALLOW;\n\n    //\n    // To change the muxing, set the peripheral mux to 0/GPIO first to avoid\n    // glitches, then change the group mux, then set the peripheral mux to\n    // its target value. Finally, set the CPU select. This procedure is\n    // described in the TRM. Unfortunately, since we don't know the pin in\n    // advance we can't hardcode a bitfield reference, so there's some tricky\n    // bit twiddling here.\n    //\n    *mux &= ~(0x3UL << (2*pin16));\n    *gmux &= ~(0x3UL << (2*pin16));\n    *gmux |= (Uint32)((muxPosition >> 2) & 0x3UL) << (2*pin16);\n    *mux |= (Uint32)(muxPosition & 0x3UL) << (2*pin16);\n\n    *csel &= ~(0x3L << (4*pin8));\n    *csel |= (Uint32)(cpu & 0x3L) << (4*pin8);\n\n    //\n    // WARNING: This code does not touch the analog mode select registers.\n    //\n\n    EDIS;\n}\n\n//\n// GPIO_SetupPinOptions - Setup up the GPIO input/output options for the\n// specified pin. The flags are a 16-bit mask produced by ORing together\n// options. For input pins, the valid flags are:\n// GPIO_PULLUP  Enable pull-up\n// GPIO_INVERT  Enable input polarity inversion\n// GPIO_SYNC  Synchronize the input latch to PLLSYSCLK\n//              (default -- you don't need to specify this)\n// GPIO_QUAL3  Use 3-sample qualification\n// GPIO_QUAL6  Use 6-sample qualification\n// GPIO_ASYNC  Do not use synchronization or qualification\n// (Note: only one of SYNC, QUAL3, QUAL6, or ASYNC is allowed)\n//\n// For output pins, the valid flags are:\n// GPIO_OPENDRAIN  Output in open drain mode\n// GPIO_PULLUP    If open drain enabled, also enable the pull-up\n// and the input qualification flags (SYNC/QUAL3/QUAL6/SYNC) listed above.\n//\n// With no flags, the default input state is synchronous with no\n// pull-up or polarity inversion. The default output state is\n// the standard digital output.\n//\nvoid\nGPIO_SetupPinOptions(Uint16 gpioNumber, Uint16 output, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *dir, *pud, *inv, *odr, *qsel;\n    Uint32 pin32, pin16, pinMask, qual;\n\n    pin32 = gpioNumber % 32;\n    pin16 = gpioNumber % 16;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    //\n    // Create pointers to the appropriate registers. This is a workaround\n    // for the way GPIO registers are defined. The standard definition\n    // in the header file makes it very easy to do named accesses of one\n    // register or bit, but hard to do arbitrary numerical accesses. It's\n    // easier to have an array of GPIO modules with identical registers,\n    // including arrays for multi-register groups like GPyQSEL1-2. But\n    // the header file doesn't define anything we can turn into an array,\n    // so manual pointer arithmetic is used instead.\n    //\n    dir = gpioBaseAddr + GPYDIR;\n    pud = gpioBaseAddr + GPYPUD;\n    inv = gpioBaseAddr + GPYINV;\n    odr = gpioBaseAddr + GPYODR;\n    qsel = gpioBaseAddr + GPYQSEL + pin32/16;\n\n    EALLOW;\n\n    //\n    // Set the data direction\n    //\n    *dir &= ~pinMask;\n    if (output == 1)\n    {\n        //\n        // Output, with optional open drain mode and pull-up\n        //\n        *dir |= pinMask;\n\n        //\n        // Enable open drain if necessary\n        //\n        if (flags & GPIO_OPENDRAIN)\n        {\n            *odr |= pinMask;\n        }\n        else\n        {\n            *odr &= ~pinMask;\n        }\n\n        //\n        // Enable pull-up if necessary. Open drain mode must be active.\n        //\n        if (flags & (GPIO_OPENDRAIN | GPIO_PULLUP))\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n    }\n\n    else\n    {\n        //\n        // Input, with optional pull-up, qualification, and polarity inversion\n        //\n        *dir &= ~pinMask;\n\n        //\n        // Enable pull-up if necessary\n        //\n        if (flags & GPIO_PULLUP)\n        {\n            *pud &= ~pinMask;\n        }\n        else\n        {\n            *pud |= pinMask;\n        }\n\n        //\n        // Invert polarity if necessary\n        //\n        if (flags & GPIO_INVERT)\n        {\n            *inv |= pinMask;\n        }\n        else\n        {\n            *inv &= ~pinMask;\n        }\n    }\n\n    //\n    // Extract the qualification parameter and load it into the register.\n    // This is also needed for open drain outputs, so we might as well do it\n    // all the time.\n    //\n    qual = (flags & GPIO_ASYNC) / GPIO_QUAL3;\n    *qsel &= ~(0x3L << (2 * pin16));\n    if (qual != 0x0)\n    {\n        *qsel |= qual << (2 * pin16);\n    }\n\n    EDIS;\n}\n\n//\n// GPIO_SetupLock - Enable or disable the GPIO register bit lock for the\n// specified pin. The valid flags are:\n// GPIO_UNLOCK  Unlock the pin setup register bits for the specified pin\n// GPIO_LOCK   Lock the pin setup register bits for the specified pin\n//\nvoid\nGPIO_SetupLock(Uint16 gpioNumber, Uint16 flags)\n{\n    volatile Uint32 *gpioBaseAddr;\n    volatile Uint32 *lock;\n    Uint32 pin32, pinMask;\n\n    pin32 = gpioNumber % 32;\n    pinMask = 1UL << pin32;\n    gpioBaseAddr = (Uint32 *)&GpioCtrlRegs + (gpioNumber/32)*GPY_CTRL_OFFSET;\n\n    //\n    // Create pointers to the appropriate registers. This is a workaround\n    // for the way GPIO registers are defined. The standard definition\n    // in the header file makes it very easy to do named accesses of one\n    // register or bit, but hard to do arbitrary numerical accesses. It's\n    // easier to have an array of GPIO modules with identical registers,\n    // including arrays for multi-register groups like GPyQSEL1-2. But\n    // the header file doesn't define anything we can turn into an array,\n    // so manual pointer arithmetic is used instead.\n    //\n    lock = gpioBaseAddr + GPYLOCK;\n\n    EALLOW;\n\n    if(flags)\n    {\n        //\n        // Lock the pin\n        //\n        *lock |= pinMask;\n    }\n\n    else\n    {\n        //\n        // Unlock the pin\n        //\n        *lock &= ~pinMask;\n    }\n    EDIS;\n}\n\n//\n// External interrupt setup\n//\nvoid\nGPIO_SetupXINT1Gpio(Uint16 gpioNumber)\n{\n    EALLOW;\n    InputXbarRegs.INPUT4SELECT = gpioNumber;       // Set XINT1 source to GPIO-pin\n    EDIS;\n}\n\nvoid\nGPIO_SetupXINT2Gpio(Uint16 gpioNumber)\n{\n    EALLOW;\n    InputXbarRegs.INPUT5SELECT = gpioNumber;       // Set XINT2 source to GPIO-pin\n    EDIS;\n}\n\nvoid\nGPIO_SetupXINT3Gpio(Uint16 gpioNumber)\n{\n    EALLOW;\n    InputXbarRegs.INPUT6SELECT = gpioNumber;       // Set XINT3 source to GPIO-pin\n    EDIS;\n}\nvoid\nGPIO_SetupXINT4Gpio(Uint16 gpioNumber)\n{\n    EALLOW;\n    InputXbarRegs.INPUT13SELECT = gpioNumber;      // Set XINT4 source to GPIO-pin\n    EDIS;\n}\n\nvoid\nGPIO_SetupXINT5Gpio(Uint16 gpioNumber)\n{\n    EALLOW;\n    InputXbarRegs.INPUT14SELECT = gpioNumber;     // Set XINT5 source to GPIO-pin\n    EDIS;\n}\n\n//\n// GPIO_ReadPin - Read the GPyDAT register bit for the specified pin.\n// Note that this returns the actual state of the pin, not the state of the\n// output latch.\n//\nUint16\nGPIO_ReadPin(Uint16 gpioNumber)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint16 pinVal;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinVal = (gpioDataReg[GPYDAT] >> (gpioNumber % 32)) & 0x1;\n\n    return pinVal;\n}\n\n//\n// GPIO_WritePin - Set the GPyDAT register bit for the specified pin.\n//\nvoid\nGPIO_WritePin(Uint16 gpioNumber, Uint16 outVal)\n{\n    volatile Uint32 *gpioDataReg;\n    Uint32 pinMask;\n\n    gpioDataReg = (volatile Uint32 *)&GpioDataRegs + (gpioNumber/32)*GPY_DATA_OFFSET;\n    pinMask = 1UL << (gpioNumber % 32);\n\n    if (outVal == 0)\n    {\n        gpioDataReg[GPYCLEAR] = pinMask;\n    }\n\n    else\n    {\n        gpioDataReg[GPYSET] = pinMask;\n    }\n}\n\n//\n// End of File\n//\n\n"},{"name":"f28004x_piectrl.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   f28004x_piectrl.c\n//\n// TITLE:  f28004x Device PIE Control Register Initialization Functions.\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"      // f28004x Headerfile Include File\n#include \"f28004x_examples.h\"    // f28004x Examples Include File\n\n//\n// InitPieCtrl - This function initializes the PIE control registers\n// to a known state.\n//\nvoid\nInitPieCtrl(void)\n{\n    //\n    // Disable Interrupts at the CPU level:\n    //\n    DINT;\n\n    //\n    // Disable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 0;\n\n    //\n    // Clear all PIEIER registers:\n    //\n    PieCtrlRegs.PIEIER1.all = 0;\n    PieCtrlRegs.PIEIER2.all = 0;\n    PieCtrlRegs.PIEIER3.all = 0;\n    PieCtrlRegs.PIEIER4.all = 0;\n    PieCtrlRegs.PIEIER5.all = 0;\n    PieCtrlRegs.PIEIER6.all = 0;\n    PieCtrlRegs.PIEIER7.all = 0;\n    PieCtrlRegs.PIEIER8.all = 0;\n    PieCtrlRegs.PIEIER9.all = 0;\n    PieCtrlRegs.PIEIER10.all = 0;\n    PieCtrlRegs.PIEIER11.all = 0;\n    PieCtrlRegs.PIEIER12.all = 0;\n\n    //\n    // Clear all PIEIFR registers:\n    //\n    PieCtrlRegs.PIEIFR1.all = 0;\n    PieCtrlRegs.PIEIFR2.all = 0;\n    PieCtrlRegs.PIEIFR3.all = 0;\n    PieCtrlRegs.PIEIFR4.all = 0;\n    PieCtrlRegs.PIEIFR5.all = 0;\n    PieCtrlRegs.PIEIFR6.all = 0;\n    PieCtrlRegs.PIEIFR7.all = 0;\n    PieCtrlRegs.PIEIFR8.all = 0;\n    PieCtrlRegs.PIEIFR9.all = 0;\n    PieCtrlRegs.PIEIFR10.all = 0;\n    PieCtrlRegs.PIEIFR11.all = 0;\n    PieCtrlRegs.PIEIFR12.all = 0;\n}\n\n//\n// EnableInterrupts - This function enables the PIE module and CPU __interrupts\n//\nvoid\nEnableInterrupts()\n{\n    //\n    // Enable the PIE\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE = 1;\n\n    //\n    // Enables PIE to drive a pulse into the CPU\n    //\n    PieCtrlRegs.PIEACK.all = 0xFFFF;\n\n    //\n    // Enable Interrupts at the CPU level\n    //\n    EINT;\n}\n\n//\n// End of file.\n//\n\n"},{"name":"f28004x_pievect.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   f28004x_pievect.c\n//\n// TITLE:  f28004x Device PIE Vector Initialization Functions\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"           // f28004x Header File Include File\n#include \"f28004x_examples.h\"         // f28004x Examples Include File\n\n//\n// Define PIE Vector Table:\n//\nconst struct PIE_VECT_TABLE PieVectTableInit = {\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    PIE_RESERVED_ISR,               // Reserved\n    TIMER1_ISR,                     // CPU Timer 1 Interrupt\n    TIMER2_ISR,                     // CPU Timer 2 Interrupt\n    DATALOG_ISR,                    // Datalogging Interrupt\n    RTOS_ISR,                       // RTOS Interrupt\n    EMU_ISR,                        // Emulation Interrupt\n    NMI_ISR,                        // Non-Maskable Interrupt\n    ILLEGAL_ISR,                    // Illegal Operation Trap\n    USER1_ISR,                      // User Defined Trap 1\n    USER2_ISR,                      // User Defined Trap 2\n    USER3_ISR,                      // User Defined Trap 3\n    USER4_ISR,                      // User Defined Trap 4\n    USER5_ISR,                      // User Defined Trap 5\n    USER6_ISR,                      // User Defined Trap 6\n    USER7_ISR,                      // User Defined Trap 7\n    USER8_ISR,                      // User Defined Trap 8\n    USER9_ISR,                      // User Defined Trap 9\n    USER10_ISR,                     // User Defined Trap 10\n    USER11_ISR,                     // User Defined Trap 11\n    USER12_ISR,                     // User Defined Trap 12\n    ADCA1_ISR,                      // 1.1 - ADCA Interrupt 1\n    ADCB1_ISR,                      // 1.2 - ADCB Interrupt 1\n    ADCC1_ISR,                      // 1.3 - ADCC Interrupt 1\n    XINT1_ISR,                      // 1.4 - XINT1 Interrupt\n    XINT2_ISR,                      // 1.5 - XINT2 Interrupt\n    PIE_RESERVED_ISR,               // 1.6 - Reserved\n    TIMER0_ISR,                     // 1.7 - Timer 0 Interrupt\n    WAKE_ISR,                       // 1.8 - Halt Wakeup Interrupt\n    EPWM1_TZ_ISR,                   // 2.1 - ePWM1 Trip Zone Interrupt\n    EPWM2_TZ_ISR,                   // 2.2 - ePWM2 Trip Zone Interrupt\n    EPWM3_TZ_ISR,                   // 2.3 - ePWM3 Trip Zone Interrupt\n    EPWM4_TZ_ISR,                   // 2.4 - ePWM4 Trip Zone Interrupt\n    EPWM5_TZ_ISR,                   // 2.5 - ePWM5 Trip Zone Interrupt\n    EPWM6_TZ_ISR,                   // 2.6 - ePWM6 Trip Zone Interrupt\n    EPWM7_TZ_ISR,                   // 2.7 - ePWM7 Trip Zone Interrupt\n    EPWM8_TZ_ISR,                   // 2.8 - ePWM8 Trip Zone Interrupt\n    EPWM1_ISR,                      // 3.1 - ePWM1 Interrupt\n    EPWM2_ISR,                      // 3.2 - ePWM2 Interrupt\n    EPWM3_ISR,                      // 3.3 - ePWM3 Interrupt\n    EPWM4_ISR,                      // 3.4 - ePWM4 Interrupt\n    EPWM5_ISR,                      // 3.5 - ePWM5 Interrupt\n    EPWM6_ISR,                      // 3.6 - ePWM6 Interrupt\n    EPWM7_ISR,                      // 3.7 - ePWM7 Interrupt\n    EPWM8_ISR,                      // 3.8 - ePWM8 Interrupt\n    ECAP1_ISR,                      // 4.1 - eCAP1 Interrupt\n    ECAP2_ISR,                      // 4.2 - eCAP2 Interrupt\n    ECAP3_ISR,                      // 4.3 - eCAP3 Interrupt\n    ECAP4_ISR,                      // 4.4 - eCAP4 Interrupt\n    ECAP5_ISR,                      // 4.5 - eCAP5 Interrupt\n    ECAP6_ISR,                      // 4.6 - eCAP6 Interrupt\n    ECAP7_ISR,                      // 4.7 - eCAP7 Interrupt\n    PIE_RESERVED_ISR,               // 4.8 - Reserved\n    EQEP1_ISR,                      // 5.1 - eQEP1 Interrupt\n    EQEP2_ISR,                      // 5.2 - eQEP2 Interrupt\n    PIE_RESERVED_ISR,               // 5.3 - Reserved\n    PIE_RESERVED_ISR,               // 5.4 - Reserved\n    PIE_RESERVED_ISR,               // 5.5 - Reserved\n    PIE_RESERVED_ISR,               // 5.6 - Reserved\n    PIE_RESERVED_ISR,               // 5.7 - Reserved\n    PIE_RESERVED_ISR,               // 5.8 - Reserved\n    SPIA_RX_ISR,                    // 6.1 - SPIA Receive Interrupt\n    SPIA_TX_ISR,                    // 6.2 - SPIA Transmit Interrupt\n    SPIB_RX_ISR,                    // 6.3 - SPIB Receive Interrupt\n    SPIB_TX_ISR,                    // 6.4 - SPIB Transmit Interrupt\n    PIE_RESERVED_ISR,               // 6.5 - Reserved\n    PIE_RESERVED_ISR,               // 6.6 - Reserved\n    PIE_RESERVED_ISR,               // 6.7 - Reserved\n    PIE_RESERVED_ISR,               // 6.8 - Reserved\n    DMA_CH1_ISR,                    // 7.1 - DMA Channel 1 Interrupt\n    DMA_CH2_ISR,                    // 7.2 - DMA Channel 2 Interrupt\n    DMA_CH3_ISR,                    // 7.3 - DMA Channel 3 Interrupt\n    DMA_CH4_ISR,                    // 7.4 - DMA Channel 4 Interrupt\n    DMA_CH5_ISR,                    // 7.5 - DMA Channel 5 Interrupt\n    DMA_CH6_ISR,                    // 7.6 - DMA Channel 6 Interrupt\n    PIE_RESERVED_ISR,               // 7.7 - Reserved\n    PIE_RESERVED_ISR,               // 7.8 - Reserved\n    I2CA_ISR,                       // 8.1 - I2CA Interrupt 1\n    I2CA_FIFO_ISR,                  // 8.2 - I2CA Interrupt 2\n    PIE_RESERVED_ISR,               // 8.3 - Reserved\n    PIE_RESERVED_ISR,               // 8.4 - Reserved\n    PIE_RESERVED_ISR,               // 8.5 - Reserved\n    PIE_RESERVED_ISR,               // 8.6 - Reserved\n    PIE_RESERVED_ISR,               // 8.7 - Reserved\n    PIE_RESERVED_ISR,               // 8.8 - Reserved\n    SCIA_RX_ISR,                    // 9.1 - SCIA Receive Interrupt\n    SCIA_TX_ISR,                    // 9.2 - SCIA Transmit Interrupt\n    SCIB_RX_ISR,                    // 9.3 - SCIB Receive Interrupt\n    SCIB_TX_ISR,                    // 9.4 - SCIB Transmit Interrupt\n    CANA0_ISR,                      // 9.5 - CANA Interrupt 0\n    CANA1_ISR,                      // 9.6 - CANA Interrupt 1\n    CANB0_ISR,                      // 9.7 - CANB Interrupt 0\n    CANB1_ISR,                      // 9.8 - CANB Interrupt 1\n    ADCA_EVT_ISR,                   // 10.1 - ADCA Event Interrupt\n    ADCA2_ISR,                      // 10.2 - ADCA Interrupt 2\n    ADCA3_ISR,                      // 10.3 - ADCA Interrupt 3\n    ADCA4_ISR,                      // 10.4 - ADCA Interrupt 4\n    ADCB_EVT_ISR,                   // 10.5 - ADCB Event Interrupt\n    ADCB2_ISR,                      // 10.6 - ADCB Interrupt 2\n    ADCB3_ISR,                      // 10.7 - ADCB Interrupt 3\n    ADCB4_ISR,                      // 10.8 - ADCB Interrupt 4\n    CLA1_1_ISR,                     // 11.1 - CLA1 Interrupt 1\n    CLA1_2_ISR,                     // 11.2 - CLA1 Interrupt 2\n    CLA1_3_ISR,                     // 11.3 - CLA1 Interrupt 3\n    CLA1_4_ISR,                     // 11.4 - CLA1 Interrupt 4\n    CLA1_5_ISR,                     // 11.5 - CLA1 Interrupt 5\n    CLA1_6_ISR,                     // 11.6 - CLA1 Interrupt 6\n    CLA1_7_ISR,                     // 11.7 - CLA1 Interrupt 7\n    CLA1_8_ISR,                     // 11.8 - CLA1 Interrupt 8\n    XINT3_ISR,                      // 12.1 - XINT3 Interrupt\n    XINT4_ISR,                      // 12.2 - XINT4 Interrupt\n    XINT5_ISR,                      // 12.3 - XINT5 Interrupt\n    PIE_RESERVED_ISR,               // 12.4 - Reserved\n    PIE_RESERVED_ISR,               // 12.5 - Reserved\n    PIE_RESERVED_ISR,               // 12.6 - Reserved\n    FPU_OVERFLOW_ISR,               // 12.7 - FPU Overflow Interrupt\n    FPU_UNDERFLOW_ISR,              // 12.8 - FPU Underflow Interrupt\n    PIE_RESERVED_ISR,               // 1.9 - Reserved\n    PIE_RESERVED_ISR,               // 1.10 - Reserved\n    PIE_RESERVED_ISR,               // 1.11 - Reserved\n    PIE_RESERVED_ISR,               // 1.12 - Reserved\n    PIE_RESERVED_ISR,               // 1.13 - Reserved\n    PIE_RESERVED_ISR,               // 1.14 - Reserved\n    PIE_RESERVED_ISR,               // 1.15 - Reserved\n    PIE_RESERVED_ISR,               // 1.16 - Reserved\n    PIE_RESERVED_ISR,               // 2.9 - Reserved\n    PIE_RESERVED_ISR,               // 2.10 - Reserved\n    PIE_RESERVED_ISR,               // 2.11 - Reserved\n    PIE_RESERVED_ISR,               // 2.12 - Reserved\n    PIE_RESERVED_ISR,               // 2.13 - Reserved\n    PIE_RESERVED_ISR,               // 2.14 - Reserved\n    PIE_RESERVED_ISR,               // 2.15 - Reserved\n    PIE_RESERVED_ISR,               // 2.16 - Reserved\n    PIE_RESERVED_ISR,               // 3.9 - Reserved\n    PIE_RESERVED_ISR,               // 3.10 - Reserved\n    PIE_RESERVED_ISR,               // 3.11 - Reserved\n    PIE_RESERVED_ISR,               // 3.12 - Reserved\n    PIE_RESERVED_ISR,               // 3.13 - Reserved\n    PIE_RESERVED_ISR,               // 3.14 - Reserved\n    PIE_RESERVED_ISR,               // 3.15 - Reserved\n    PIE_RESERVED_ISR,               // 3.16 - Reserved\n    PIE_RESERVED_ISR,               // 4.9 - Reserved\n    PIE_RESERVED_ISR,               // 4.10 - Reserved\n    PIE_RESERVED_ISR,               // 4.11 - Reserved\n    PIE_RESERVED_ISR,               // 4.12 - Reserved\n    PIE_RESERVED_ISR,               // 4.13 - Reserved\n    ECAP6_2_ISR,                    // 4.14 - eCAP6_2 Interrupt\n    ECAP7_2_ISR,                    // 4.15 - eCAP7_2 Interrupt\n    PIE_RESERVED_ISR,               // 4.16 - Reserved\n    SD1_ISR,                        // 5.9 - SD1 Interrupt\n    PIE_RESERVED_ISR,               // 5.10 - Reserved\n    PIE_RESERVED_ISR,               // 5.11 - Reserved\n    PIE_RESERVED_ISR,               // 5.12 - Reserved\n    SD1DR1_ISR,                     // 5.13 - SD1DR1 Interrupt\n    SD1DR2_ISR,                     // 5.14 - SD1DR2 Interrupt\n    SD1DR3_ISR,                     // 5.15 - SD1DR3 Interrupt\n    SD1DR4_ISR,                     // 5.16 - SD1DR4 Interrupt\n    PIE_RESERVED_ISR,               // 6.9 - Reserved\n    PIE_RESERVED_ISR,               // 6.10 - Reserved\n    PIE_RESERVED_ISR,               // 6.11 - Reserved\n    PIE_RESERVED_ISR,               // 6.12 - Reserved\n    PIE_RESERVED_ISR,               // 6.13 - Reserved\n    PIE_RESERVED_ISR,               // 6.14 - Reserved\n    PIE_RESERVED_ISR,               // 6.15 - Reserved\n    PIE_RESERVED_ISR,               // 6.16 - Reserved\n    PIE_RESERVED_ISR,               // 7.9 - Reserved\n    PIE_RESERVED_ISR,               // 7.10 - Reserved\n    FSITXA1_ISR,                    // 7.11 - FSITXA1 Interrupt\n    FSITXA2_ISR,                    // 7.12 - FSITXA2 Interrupt\n    FSIRXA1_ISR,                    // 7.13 - FSIRXA1 Interrupt\n    FSIRXA2_ISR,                    // 7.14 - FSIRXA2 Interrupt \n    CLA1PROMCRC_ISR,                // 7.15 - CLA1PROMCRC Interrupt\n    PIE_RESERVED_ISR,               // 7.16 - Reserved\n    LINA_0_ISR,                     // 8.9 - LINA Interrupt0\n    LINA_1_ISR,                     // 8.10 - LINA Interrupt1\n    PIE_RESERVED_ISR,               // 8.11 - Reserved\n    PIE_RESERVED_ISR,               // 8.12 - Reserved\n    PMBUSA_ISR,                     // 8.13 - PMBUSA Interrupt\n    PIE_RESERVED_ISR,               // 8.14 - Reserved\n    PIE_RESERVED_ISR,               // 8.15 - Reserved\n    PIE_RESERVED_ISR,               // 8.16 - Reserved\n    PIE_RESERVED_ISR,               // 9.9 - Reserved\n    PIE_RESERVED_ISR,               // 9.10 - Reserved\n    PIE_RESERVED_ISR,               // 9.11 - Reserved\n    PIE_RESERVED_ISR,               // 9.12 - Reserved\n    PIE_RESERVED_ISR,               // 9.13 - Reserved\n    PIE_RESERVED_ISR,               // 9.14 - Reserved\n    PIE_RESERVED_ISR,               // 9.15 - Reserved\n    PIE_RESERVED_ISR,               // 9.16 - Reserved\n    ADCC_EVT_ISR,                   // 10.9 - ADCC Event Interrupt\n    ADCC2_ISR,                      // 10.10 - ADCC Interrupt 2\n    ADCC3_ISR,                      // 10.11 - ADCC Interrupt 3\n    ADCC4_ISR,                      // 10.12 - ADCC Interrupt 4\n    PIE_RESERVED_ISR,               // 10.13 - Reserved\n    PIE_RESERVED_ISR,               // 10.14 - Reserved\n    PIE_RESERVED_ISR,               // 10.15 - Reserved\n    PIE_RESERVED_ISR,               // 10.16 - Reserved\n    PIE_RESERVED_ISR,               // 11.9 - Reserved\n    PIE_RESERVED_ISR,               // 11.10 - Reserved\n    PIE_RESERVED_ISR,               // 11.11 - Reserved\n    PIE_RESERVED_ISR,               // 11.12 - Reserved\n    PIE_RESERVED_ISR,               // 11.13 - Reserved\n    PIE_RESERVED_ISR,               // 11.14 - Reserved\n    PIE_RESERVED_ISR,               // 11.15 - Reserved\n    PIE_RESERVED_ISR,               // 11.16 - Reserved\n    PIE_RESERVED_ISR,               // 12.9 - Reserved\n    RAM_CORRECTABLE_ERROR_ISR,     // 12.10 - RAM Correctable Error Interrupt\n    FLASH_CORRECTABLE_ERROR_ISR,   // 12.11 - Flash Correctable Error Interrupt\n    RAM_ACCESS_VIOLATION_ISR,      // 12.12 - RAM Access Violation Interrupt\n    SYS_PLL_SLIP_ISR,              // 12.13 - System PLL Slip Interrupt\n    PIE_RESERVED_ISR,              // 12.14 - Reserved\n    CLA_OVERFLOW_ISR,              // 12.15 - CLA Overflow Interrupt\n    CLA_UNDERFLOW_ISR              // 12.16 - CLA Underflow Interrupt\n};\n\n//\n// InitPieVectTable - This function initializes the PIE vector table to a known\n// state. This function must be executed after boot time.\n//\nvoid\nInitPieVectTable(void)\n{\n    Uint16  i;\n    Uint32  *Source  =  (void  *)  &PieVectTableInit;\n    Uint32  *Dest  =  (void  *)  &PieVectTable;\n\n    //\n    // Do not write over first 3 32-bit locations (these locations are\n    // initialized by Boot ROM with boot variables)\n    //\n    Source  =  Source  +  3;\n    Dest  =  Dest  +  3;\n\n    EALLOW;\n\n    for(i  =  0;  i  <  221;  i++)\n    {\n        *Dest++  =  *Source++;\n    }\n\n    EDIS;\n\n    //\n    // Enable the PIE Vector Table\n    //\n    PieCtrlRegs.PIECTRL.bit.ENPIE  =  1;\n}\n\n//\n// End of File\n//\n\n"},{"name":"f28004x_sysctrl.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   f28004x_sysctrl.c\n//\n// TITLE:  f28004x Device System Control Initialization & Support Functions.\n//\n// DESCRIPTION:  Example initialization of system resources.\n//\n//###########################################################################\n//\n//\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n//\n// Included Files\n//\n#include \"f28004x_device.h\"     // Headerfile Include File\n#include \"f28004x_examples.h\"   // Examples Include File\n#ifdef __cplusplus\nusing std::memcpy;\n#endif\n\n//\n// Functions that will be run from RAM need to be assigned to\n// a different section.  This section will then be mapped to a load and\n// run address using the linker cmd file.\n//\n// *IMPORTANT*\n// IF RUNNING FROM FLASH, PLEASE COPY OVER THE SECTION \".TI.ramfunc\"  FROM FLASH\n// TO RAM PRIOR TO CALLING InitSysCtrl(). THIS PREVENTS THE MCU FROM THROWING\n// AN EXCEPTION WHEN A CALL TO DELAY_US() IS MADE.\n//\n#ifndef __cplusplus\n#pragma CODE_SECTION(InitFlash, \".TI.ramfunc\");\n#pragma CODE_SECTION(FlashOff, \".TI.ramfunc\");\n#endif\n\n//\n// The following values are used to validate PLL Frequency using DCC\n//\n#define   PLL_RETRIES              100\n#define   PLL_LOCK_TIMEOUT        2000\n#define   DCC_COUNTER0_WINDOW      100\n\n//\n// Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1\n// register.\n// Delay = 300 NOPs\n//\n#define SYSCTRL_CLKSRCCTL1_DELAY  asm(\" RPT #250 || NOP \\n RPT #50 || NOP\")\n\n//\n// InitSysCtrl - Initialization of system resources.\n//\nvoid\nInitSysCtrl(void)\n{\n    //\n    // Disable the watchdog\n    //\n    DisableDog();\n\n#ifdef _FLASH\n    //\n    // Copy time critical code and Flash setup code to RAM\n    // This includes the following functions:  InitFlash();\n    // The  RamfuncsLoadStart, RamfuncsLoadSize, and RamfuncsRunStart\n    // symbols are created by the linker. Refer to the device .cmd file.\n    //\n    memcpy(&RamfuncsRunStart, &RamfuncsLoadStart, (size_t)&RamfuncsLoadSize);\n\n    //\n    // Call Flash Initialization to setup flash waitstates\n    // This function must reside in RAM\n    //\n    InitFlash();\n#endif\n\n    //\n    // PLLSYSCLK = (XTAL_OSC) * (IMULT + FMULT) / (PLLSYSCLKDIV)\n    //\n    InitSysPll(XTAL_OSC,IMULT_10,FMULT_0,PLLCLK_BY_2);\n\n#ifndef _FLASH\n    //\n    // Call Device_cal function when run using debugger\n    // This function is called as part of the Boot code. The function is called\n    // in the InitSysCtrl function since during debug time resets, the boot code\n    // will not be executed and the gel script will reinitialize all the\n    // registers and the calibrated values will be lost.\n    //\n    Device_cal();\n#endif\n\n    //\n    // Turn on all peripherals\n    //\n    InitPeripheralClocks();\n}\n\n//\n// InitPeripheralClocks - This function initializes the clocks for the\n// peripherals. Note: In order to reduce power consumption, turn off the\n// clocks to any peripheral that is not specified for your part-number or is\n// not used in the application\n//\nvoid\nInitPeripheralClocks()\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.bit.CLA1 = 1;\n    CpuSysRegs.PCLKCR0.bit.DMA = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER0 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER1 = 1;\n    CpuSysRegs.PCLKCR0.bit.CPUTIMER2 = 1;\n    CpuSysRegs.PCLKCR0.bit.HRPWM = 1;\n    CpuSysRegs.PCLKCR0.bit.TBCLKSYNC = 1;\n\n    CpuSysRegs.PCLKCR2.bit.EPWM1 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM2 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM3 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM4 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM5 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM6 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM7 = 1;\n    CpuSysRegs.PCLKCR2.bit.EPWM8 = 1;\n\n    CpuSysRegs.PCLKCR3.bit.ECAP1 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP2 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP3 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP4 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP5 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP6 = 1;\n    CpuSysRegs.PCLKCR3.bit.ECAP7 = 1;\n\n    CpuSysRegs.PCLKCR4.bit.EQEP1 = 1;\n    CpuSysRegs.PCLKCR4.bit.EQEP2 = 1;\n\n    CpuSysRegs.PCLKCR6.bit.SD1 = 1;\n\n    CpuSysRegs.PCLKCR7.bit.SCI_A = 1;\n    CpuSysRegs.PCLKCR7.bit.SCI_B = 1;\n\n    CpuSysRegs.PCLKCR8.bit.SPI_A = 1;\n    CpuSysRegs.PCLKCR8.bit.SPI_B = 1;\n\n    CpuSysRegs.PCLKCR9.bit.I2C_A = 1;\n\n    CpuSysRegs.PCLKCR10.bit.CAN_A = 1;\n    CpuSysRegs.PCLKCR10.bit.CAN_B = 1;\n\n    CpuSysRegs.PCLKCR13.bit.ADC_A = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_B = 1;\n    CpuSysRegs.PCLKCR13.bit.ADC_C = 1;\n\n    CpuSysRegs.PCLKCR14.bit.CMPSS1 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS2 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS3 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS4 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS5 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS6 = 1;\n    CpuSysRegs.PCLKCR14.bit.CMPSS7 = 1;\n\n    CpuSysRegs.PCLKCR15.bit.PGA1 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA2 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA3 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA4 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA5 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA6 = 1;\n    CpuSysRegs.PCLKCR15.bit.PGA7 = 1;\n\n    CpuSysRegs.PCLKCR18.bit.FSIRX_A = 1;\n    CpuSysRegs.PCLKCR18.bit.FSITX_A = 1;\n\n    CpuSysRegs.PCLKCR16.bit.DAC_A = 1;\n    CpuSysRegs.PCLKCR16.bit.DAC_B = 1;\n\n    CpuSysRegs.PCLKCR19.bit.LIN_A = 1;\n\n    CpuSysRegs.PCLKCR20.bit.PMBUS_A = 1;\n\n    CpuSysRegs.PCLKCR21.bit.DCC_0 = 1;\n\n    EDIS;\n}\n\n//\n// DisablePeripheralClocks -\n//\nvoid\nDisablePeripheralClocks()\n{\n    EALLOW;\n\n    CpuSysRegs.PCLKCR0.all = 0;\n    CpuSysRegs.PCLKCR2.all = 0;\n    CpuSysRegs.PCLKCR3.all = 0;\n    CpuSysRegs.PCLKCR4.all = 0;\n    CpuSysRegs.PCLKCR6.all = 0;\n    CpuSysRegs.PCLKCR7.all = 0;\n    CpuSysRegs.PCLKCR8.all = 0;\n    CpuSysRegs.PCLKCR9.all = 0;\n    CpuSysRegs.PCLKCR10.all = 0;\n    CpuSysRegs.PCLKCR13.all = 0;\n    CpuSysRegs.PCLKCR14.all = 0;\n    CpuSysRegs.PCLKCR15.all = 0;\n    CpuSysRegs.PCLKCR16.all = 0;\n    CpuSysRegs.PCLKCR18.all = 0;\n    CpuSysRegs.PCLKCR19.all = 0;\n    CpuSysRegs.PCLKCR20.all = 0;\n    CpuSysRegs.PCLKCR21.all = 0;\n\n    EDIS;\n}\n\n//\n// InitFlash - This function initializes the Flash Control registers\n//                  CAUTION\n// This function MUST be executed out of RAM. Executing it\n// out of OTP/Flash will yield unpredictable results\n//\n#ifdef __cplusplus\n#pragma CODE_SECTION(\".TI.ramfunc\");\n#endif\nvoid\nInitFlash(void)\n{\n    EALLOW;\n\n    //\n    // At reset bank and pump are in sleep\n    // A Flash access will power up the bank and pump automatically\n    //\n    // Power up Flash bank and pump and this also sets the fall back mode of\n    // flash and pump as active\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0x1;\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0x3;\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR1 = 0x3;\n\n    //\n    // Disable Cache and prefetch mechanism before changing wait states\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 0;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 0;\n\n    //\n    // Set waitstates according to frequency\n    //                CAUTION\n    // Minimum waitstates required for the flash operating\n    // at a given CPU rate must be characterized by TI.\n    // Refer to the datasheet for the latest information.\n    //\n#if CPU_FRQ_100MHZ\n    if((ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL == 0x0)   ||\n       (ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL == 0x2)   ||\n       (ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL == 0x3))\n    {\n        Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x5;\n    }\n    else\n    {\n        Flash0CtrlRegs.FRDCNTL.bit.RWAIT = 0x4;\n    }\n#endif\n\n    //\n    // Enable Cache and prefetch mechanism to improve performance\n    // of code executed from Flash.\n    //\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.DATA_CACHE_EN = 1;\n    Flash0CtrlRegs.FRD_INTF_CTRL.bit.PREFETCH_EN = 1;\n\n    //\n    // At reset, ECC is enabled. If it is disabled by application software\n    // and if application again wants to enable ECC\n    //\n    Flash0EccRegs.ECC_ENABLE.bit.ENABLE = 0xA;\n\n    EDIS;\n\n    //\n    // Force a pipeline flush to ensure that the write to\n    // the last register configured occurs before returning.\n    //\n    __asm(\" RPT #7 || NOP\");\n}\n\n//\n// FlashOff - This function powers down the flash\n//                   CAUTION\n// This function MUST be executed out of RAM. Executing it\n// out of OTP/Flash will yield unpredictable results.\n// Note: a flash access after the flash pump and banks are powered down will\n// wake the pump and bank\n//\n#ifdef __cplusplus\n#pragma CODE_SECTION(\".TI.ramfunc\");\n#endif\nvoid\nFlashOff(void)\n{\n    EALLOW;\n\n    //\n    // Configure the fallback power mode as sleep\n    //\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR0 = 0;\n    Flash0CtrlRegs.FBFALLBACK.bit.BNKPWR1 = 0;\n\n    //\n    // Configure the fallback power mode as sleep\n    //\n    Flash0CtrlRegs.FPAC1.bit.PMPPWR = 0;\n\n    EDIS;\n}\n\n//\n// ServiceDog - This function resets the watchdog timer.\n// Enable this function for using ServiceDog in the application\n//\nvoid\nServiceDog(void)\n{\n    EALLOW;\n    WdRegs.WDKEY.bit.WDKEY = 0x0055;\n    WdRegs.WDKEY.bit.WDKEY = 0x00AA;\n    EDIS;\n}\n\n//\n// DisableDog - This function disables the watchdog timer.\n//\nvoid\nDisableDog(void)\n{\n    volatile Uint16 temp;\n    EALLOW;\n\n    //\n    // Grab the clock config so we don't clobber it\n    //\n    temp = WdRegs.WDCR.all & 0x0007;\n    WdRegs.WDCR.all = 0x0068 | temp;\n    EDIS;\n}\n\n//\n// InitPll - This function initializes the PLL registers.\n//\n// Note: This function uses the DCC to check that the PLLRAWCLK is running at\n// the expected rate. If you are using the DCC, you must back up its\n// configuration before calling this function and restore it afterward.\n//\nvoid\nInitSysPll(Uint16 clock_source, Uint16 imult, Uint16 fmult, Uint16 divsel)\n{\n    Uint32 timeout, retries, temp_syspllmult, pllLockStatus;\n    bool status;\n\n    if(((clock_source & 0x3) == ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL)    &&\n       (((clock_source & 0x4) >> 2) == ClkCfgRegs.XTALCR.bit.SE)           &&\n                     (imult  == ClkCfgRegs.SYSPLLMULT.bit.IMULT)           &&\n                     (fmult  == ClkCfgRegs.SYSPLLMULT.bit.FMULT)           &&\n                     (divsel == ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV))\n    {\n        //\n        // Everything is set as required, so just return\n        //\n        return;\n    }\n\n    if(((clock_source & 0x3) != ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL) ||\n       (((clock_source & 0x4) >> 2) != ClkCfgRegs.XTALCR.bit.SE))\n    {\n        switch (clock_source)\n        {\n            case INT_OSC1:\n                SysIntOsc1Sel();\n                break;\n\n            case INT_OSC2:\n                SysIntOsc2Sel();\n                break;\n\n            case XTAL_OSC:\n                SysXtalOscSel();\n                break;\n\n            case XTAL_OSC_SE:\n                SysXtalOscSESel();\n                break;\n        }\n    }\n\n    EALLOW;\n\n    //\n    // First modify the PLL multipliers\n    //\n    if(imult != ClkCfgRegs.SYSPLLMULT.bit.IMULT ||\n       fmult != ClkCfgRegs.SYSPLLMULT.bit.FMULT)\n    {\n        //\n        // Bypass PLL and set dividers to /1\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n\n        //\n        // Delay of at least 60 OSCCLK cycles required post PLL bypass\n        //\n        asm(\" RPT #60 || NOP\");\n\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = 0;\n\n        //\n        // Evaluate PLL multipliers\n        //\n        temp_syspllmult = ((fmult << 8U) | imult);\n\n        //\n        // Loop to retry locking the PLL should the DCC module indicate\n        // that it was not successful.\n        //\n        for(retries = 0; (retries < PLL_RETRIES); retries++)\n        {\n            EALLOW;\n\n            //\n            // Disable SYSPLL (Turn off PLL)\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n\n            //\n            // Atleast 60 cycle delay between powerdown to powerup\n            //\n            asm(\" RPT #60 || NOP\");\n\n            //\n            // Program PLL multipliers\n            //\n            ClkCfgRegs.SYSPLLMULT.all = temp_syspllmult;\n\n            //\n            // Enable SYSPLL\n            //\n            ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 1;\n\n            timeout = PLL_LOCK_TIMEOUT;\n            pllLockStatus = ClkCfgRegs.SYSPLLSTS.bit.LOCKS;\n\n            //\n            // Wait for the SYSPLL lock\n            //\n            while((pllLockStatus != 1) && (timeout != 0U))\n            {\n                pllLockStatus = ClkCfgRegs.SYSPLLSTS.bit.LOCKS;\n                timeout--;\n            }\n\n            EDIS;\n\n            status = IsPLLValid(clock_source, imult, fmult);\n\n            //\n            // Check DCC Status, if no error break the loop\n            //\n            if(status)\n            {\n                break;\n            }\n        }\n    }\n    else\n    {\n        status = true;\n    }\n\n    if(status)\n    {\n        EALLOW;\n        //\n        // Set divider to produce slower output frequency to limit current increase\n        //\n        if(divsel != PLLCLK_BY_126)\n        {\n            ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel + 1;\n        }\n        else\n        {\n            ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n        }\n\n        //\n        // Enable PLLSYSCLK is fed from system PLL clock\n        //\n        ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 1;\n\n        //\n        // Small 100 cycle delay\n        //\n        asm(\" RPT #100 || NOP\");\n\n        //\n        // Set the divider to user value\n        //\n        ClkCfgRegs.SYSCLKDIVSEL.bit.PLLSYSCLKDIV = divsel;\n        EDIS;\n    }\n}\n\n//\n// CsmUnlock - This function unlocks the CSM. User must replace 0xFFFF's with\n// current password for the DSP.\n//\nUint16\nCsmUnlock()\n{\n    //\n    // Write to the key registers to unlock the device. The 0x0FFFFFFFF's\n    // are dummmy passwords. User should replace them with the correct password\n    // for the DSP.\n    // Note: F28004x has default password keys which are not all 0xFFFFFFFF.\n    // See DCSM chapter of Technical Reference Manual for default passwords.\n    EALLOW;\n\n    DcsmBank0Z1Regs.Z1_CSMKEY0 = 0xFFFFFFFF;\n    DcsmBank0Z1Regs.Z1_CSMKEY1 = 0xFFFFFFFF;\n    DcsmBank0Z1Regs.Z1_CSMKEY2 = 0xFFFFFFFF;\n    DcsmBank0Z1Regs.Z1_CSMKEY3 = 0xFFFFFFFF;\n\n    DcsmBank0Z2Regs.Z2_CSMKEY0 = 0xFFFFFFFF;\n    DcsmBank0Z2Regs.Z2_CSMKEY1 = 0xFFFFFFFF;\n    DcsmBank0Z2Regs.Z2_CSMKEY2 = 0xFFFFFFFF;\n    DcsmBank0Z2Regs.Z2_CSMKEY3 = 0xFFFFFFFF;\n    EDIS;\n\n    return 0;\n}\n\n//\n// SysIntOsc1Sel - This function switches to Internal Oscillator 1 and turns\n// off all other clock sources to minimize power consumption\n//\nvoid\nSysIntOsc1Sel (void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 2; // Clk Src = INTOSC1\n    ClkCfgRegs.XTALCR.bit.OSCOFF=1;             // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// SysIntOsc2Sel - This function switches to Internal oscillator 2 from\n// External Oscillator and turns off all other clock sources to minimize\n// power consumption\n// NOTE: If there is no external clock connection, when switching from\n//       INTOSC1 to INTOSC2, EXTOSC and XLCKIN must be turned OFF prior\n//       to switching to internal oscillator 1\n//\nvoid\nSysIntOsc2Sel (void)\n{\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.INTOSC2OFF=0;         // Turn on INTOSC2\n    SYSCTRL_CLKSRCCTL1_DELAY;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 0;     // Clk Src = INTOSC2\n    ClkCfgRegs.XTALCR.bit.OSCOFF=1;                 // Turn off XTALOSC\n    EDIS;\n}\n\n//\n// PollX1Counter - Clear the X1CNT counter and then wait for it to saturate\n// four times.\n//\nstatic void\nPollX1Counter(void)\n{\n    Uint16 loopCount = 0;\n\n    //\n    // Delay for 1 ms while the XTAL powers up\n    //\n    // 2000 loops, 5 cycles per loop + 9 cycles overhead = 10009 cycles\n    //\n    F28x_usDelay(2000);\n\n    //\n    // Clear and saturate X1CNT 4 times to guarantee operation\n    //\n    do\n    {\n        //\n        // Keep clearing the counter until it is no longer saturated\n        //\n        while(ClkCfgRegs.X1CNT.all > 0x1FF)\n        {\n            ClkCfgRegs.X1CNT.bit.CLR = 1;\n        }\n\n        //\n        // Wait for the X1 clock to saturate\n        //\n        while(ClkCfgRegs.X1CNT.all != 0x3FFU)\n        {\n            ;\n        }\n\n        //\n        // Increment the counter\n        //\n        loopCount++;\n    }while(loopCount < 4);\n}\n\n//\n// SysXtalOscSel - This function switches to External CRYSTAL oscillator and\n// turns off all other clock sources to minimize power consumption. This option\n// may not be available on all device packages\n//\nvoid\nSysXtalOscSel (void)\n{\n    EALLOW;\n    ClkCfgRegs.XTALCR.bit.OSCOFF = 0;     // Turn on XTALOSC\n    ClkCfgRegs.XTALCR.bit.SE = 0;         // Select crystal mode\n    EDIS;\n\n    //\n    // Wait for the X1 clock to saturate\n    //\n    PollX1Counter();\n\n    //\n    // Select XTAL as the oscillator source\n    //\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;\n    EDIS;\n\n    //\n    // If a missing clock failure was detected, try waiting for the X1 counter\n    // to saturate again. Consider modifying this code to add a 10ms timeout.\n    //\n    while(ClkCfgRegs.MCDCR.bit.MCLKSTS != 0)\n    {\n        EALLOW;\n        ClkCfgRegs.MCDCR.bit.MCLKCLR = 1;\n        EDIS;\n\n        //\n        // Wait for the X1 clock to saturate\n        //\n        PollX1Counter();\n\n        //\n        // Select XTAL as the oscillator source\n        //\n        EALLOW;\n        ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;\n        EDIS;\n    }\n}\n\n//\n// SysXtalOscSESel - This function switches to external oscillator in\n// single-ended mode and turns off all other clock sources to minimize power\n// consumption. This option may not be available on all device packages\n//\nvoid\nSysXtalOscSESel (void)\n{\n    EALLOW;\n    ClkCfgRegs.XTALCR.bit.OSCOFF = 0;     // Turn on XTALOSC\n    ClkCfgRegs.XTALCR.bit.SE = 1;         // Select single-ended mode\n    EDIS;\n\n    //\n    // Wait for the X1 clock to saturate\n    //\n    PollX1Counter();\n\n    //\n    // Select XTALOSC as the oscillator source\n    //\n    EALLOW;\n    ClkCfgRegs.CLKSRCCTL1.bit.OSCCLKSRCSEL = 1;\n    EDIS;\n\n    //\n    // If missing clock detected, there is something wrong with the oscillator\n    // module.\n    //\n    if(ClkCfgRegs.MCDCR.bit.MCLKSTS != 0)\n    {\n        ESTOP0;\n    }\n}\n\n//\n// IDLE - Enter IDLE mode\n//\nvoid\nIDLE()\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_IDLE;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//\n// HALT - Enter HALT mode\n//\nvoid\nHALT()\n{\n    EALLOW;\n    CpuSysRegs.LPMCR.bit.LPM = LPM_HALT;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLCLKEN = 0;\n    ClkCfgRegs.SYSPLLCTL1.bit.PLLEN = 0;\n    EDIS;\n    asm(\" IDLE\");\n}\n\n//*****************************************************************************\n//\n// SysCtl_isPLLValid()\n//\n//*****************************************************************************\nbool\nIsPLLValid(Uint16 oscSource, Uint16 imult, Uint16 fmult)\n{\n    Uint32 dccCounterSeed0, dccCounterSeed1, dccValidSeed0;\n\n    //\n    // Setting Counter0 & Valid Seed Value with +/-12% tolerance\n    //\n    dccCounterSeed0 = DCC_COUNTER0_WINDOW - 12U;\n    dccValidSeed0 = 24U;\n\n    //\n    // Multiplying Counter-0 window with PLL Integer Multiplier\n    //\n    dccCounterSeed1 = DCC_COUNTER0_WINDOW * imult;\n\n    //\n    // Multiplying Counter-0 window with PLL Fractional Multiplier\n    //\n    switch(fmult)\n    {\n        case FMULT_0pt25:\n            //\n            // FMULT * CNTR0 Window = 0.25 * 100 = 25, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 25U;\n            break;\n        case FMULT_0pt5:\n            //\n            // FMULT * CNTR0 Window = 0.5 * 100 = 50, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 50U;\n            break;\n        case FMULT_0pt75:\n            //\n            // FMULT * CNTR0 Window = 0.75 * 100 = 75, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 75U;\n            break;\n        default:\n            //\n            // No fractional multiplier\n            //\n            dccCounterSeed1 = dccCounterSeed1;\n            break;\n    }\n\n    //\n    // Enable Peripheral Clock Domain PCLKCR21 for DCC\n    //\n    EALLOW;\n    CpuSysRegs.PCLKCR21.bit.DCC_0 = 1;\n\n    //\n    // Clear Error & Done Flag\n    //\n    Dcc0Regs.DCCSTATUS.bit.ERR = 1;\n    Dcc0Regs.DCCSTATUS.bit.DONE = 1;\n\n    //\n    // Disable DCC\n    //\n    Dcc0Regs.DCCGCTRL.bit.DCCENA = 0x5;\n\n    //\n    // Disable Error Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.ERRENA = 0x5;\n\n    //\n    // Disable Done Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.DONEENA = 0x5;\n\n    //\n    // Configure Clock Source0 to whatever is set as a clock source for PLL\n    //\n    switch(oscSource)\n    {\n        case INT_OSC1:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 1; // Clk Src0 = INTOSC1\n            break;\n\n        case INT_OSC2:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 2; // Clk Src0 = INTOSC2\n            break;\n\n        case XTAL_OSC:\n        case XTAL_OSC_SE:\n            Dcc0Regs.DCCCLKSRC0.bit.CLKSRC0 = 0; // Clk Src0 = XTAL\n            break;\n    }\n\n    //\n    // Configure Clock Source1 to PLL\n    //\n    Dcc0Regs.DCCCLKSRC1.bit.KEY = 0xA; // Clk Src1 Key to enable clock source selection for count1\n    Dcc0Regs.DCCCLKSRC1.bit.CLKSRC1 = 0; // Clk Src1 = PLL\n\n    //\n    // Configure COUNTER-0, COUNTER-1 & Valid Window\n    //\n    Dcc0Regs.DCCCNTSEED0.bit.COUNTSEED0 = dccCounterSeed0; // Loaded Counter0 Value\n    Dcc0Regs.DCCVALIDSEED0.bit.VALIDSEED = dccValidSeed0;  // Loaded Valid Value\n    Dcc0Regs.DCCCNTSEED1.bit.COUNTSEED1 = dccCounterSeed1; // Loaded Counter1 Value\n\n    //\n    // Enable Single Shot Mode\n    //\n    Dcc0Regs.DCCGCTRL.bit.SINGLESHOT = 0xA;\n\n    //\n    // Enable Error Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.ERRENA = 0xA;\n\n    //\n    // Enable Done Signal\n    //\n    Dcc0Regs.DCCGCTRL.bit.DONEENA = 0xA;\n\n    //\n    // Enable DCC to start counting\n    //\n    Dcc0Regs.DCCGCTRL.bit.DCCENA = 0xA;\n    EDIS;\n\n    //\n    // Set time out for the loop\n    //\n    uint32_t timeout = dccCounterSeed1;\n\n    //\n    // Wait until Error or Done Flag is generated\n    //\n    while(((Dcc0Regs.DCCSTATUS.all & 3) == 0) && (timeout != 0U))\n    {\n        timeout--;\n    }\n\n    //\n    // Returns true if DCC completes without error\n    //\n    return(((Dcc0Regs.DCCSTATUS.all & 3) == 2) && (Dcc0Regs.DCCCNT0.all == 0) &&\n           (Dcc0Regs.DCCVALID0.all == 0) && (Dcc0Regs.DCCCNT1.all == 0));\n}\n//\n// End of File\n//\n\n"},{"name":"f28004x_usdelay.asm","type":"other","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\device_support\\f28004x\\common\\source","tag":"","groupDisplay":"Other files","code":";;#############################################################################\n;;\n;; FILE:   f28004x_usdelay.asm\n;;\n;; TITLE:  Simple Delay Function\n;;\n;; DESCRIPTION:\n;;\n;;  This is a simple delay function that can be used to insert a specified\n;;  delay into code.\n;;  This function is only accurate if executed from internal zero-waitstate\n;;  SARAM. If it is executed from waitstate memory then the delay will be\n;;  longer then specified.\n;;  To use this function:\n;;   1 - update the CPU clock speed in the f28004x_examples.h\n;;     file.\n;;   2 - Call this function by using the DELAY_US(A) macro\n;;     that is defined in the f28004x_device.h file.  This macro\n;;     will convert the number of microseconds specified\n;;     into a loop count for use with this function.\n;;     This count will be based on the CPU frequency you specify.\n;;   3 - For the most accurate delay\n;;     - Execute this function in 0 waitstate RAM.\n;;     - Disable interrupts before calling the function\n;;       If you do not disable interrupts, then think of\n;;       this as an \"at least\" delay function as the actual\n;;       delay may be longer.\n;;   The C assembly call from the DELAY_US(time) macro will\n;;   look as follows:\n;;   extern void Delay(long LoopCount);\n;;         MOV   AL,#LowLoopCount\n;;         MOV   AH,#HighLoopCount\n;;         LCR   _Delay\n;;   Or as follows (if count is less then 16-bits):\n;;         MOV   ACC,#LoopCount\n;;         LCR   _Delay\n;;#############################################################################\n;; $Copyright:\n;// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n;//\n;// Redistribution and use in source and binary forms, with or without \n;// modification, are permitted provided that the following conditions \n;// are met:\n;// \n;//   Redistributions of source code must retain the above copyright \n;//   notice, this list of conditions and the following disclaimer.\n;// \n;//   Redistributions in binary form must reproduce the above copyright\n;//   notice, this list of conditions and the following disclaimer in the \n;//   documentation and/or other materials provided with the   \n;//   distribution.\n;// \n;//   Neither the name of Texas Instruments Incorporated nor the names of\n;//   its contributors may be used to endorse or promote products derived\n;//   from this software without specific prior written permission.\n;// \n;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n;// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n;// $\n;;#############################################################################\n\n       .def _F28x_usDelay\n       .sect \".TI.ramfunc\"\n\n        .global  __F28x_usDelay\n_F28x_usDelay:\n        SUB    ACC,#1\n        BF     _F28x_usDelay,GEQ    ;; Loop if ACC >= 0\n        LRETR\n\n;There is a 9/10 cycle overhead and each loop\n;takes five cycles. The LoopCount is given by\n;the following formula:\n;  DELAY_CPU_CYCLES = 9 + 5*LoopCount\n; LoopCount = (DELAY_CPU_CYCLES - 9) / 5\n; The macro DELAY_US(A) performs this calculation for you\n\n;;#############################################################################\n;; End of file\n;;#############################################################################\n\n"},{"name":"profiler_Support.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\tic2000\\src","tag":"","groupDisplay":"Other files","code":"/* Copyrights 2016, MathWorks Inc */\n#include \"MW_target_hardware_resources.h\"\n#include \"rtwtypes.h\"\n\nvoid config_profilerTimer(void)\n{\n  /* InitCpuTimers() - CPU Timers are initialized in\n   * MW_c28xx_board.c in the generated code.\n   */\n  CpuTimer1Regs.PRD.all = 0xFFFFFFFF;  /* max Period*/\n  CpuTimer1Regs.TIM.all = 0xFFFFFFFF;  /* set Ctr*/\n  CpuTimer1Regs.TPR.all = 0x00;        /* no prescaler    */\n  StartCpuTimer1();\n}\n\n/* EOF */\n"},{"name":"sysctl.c","type":"source","group":"legacy","path":"C:\\Users\\Lukas\\Documents\\MechProjELS\\Matlab\\RealTimeMachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ti\\c2000\\C2000Ware_4_00_00_00\\driverlib\\f28004x\\driverlib","tag":"","groupDisplay":"Other files","code":"//###########################################################################\n//\n// FILE:   sysctl.c\n//\n// TITLE:  C28x system control driver.\n//\n//###########################################################################\n// $Copyright:\n// Copyright (C) 2021 Texas Instruments Incorporated - http://www.ti.com/\n//\n// Redistribution and use in source and binary forms, with or without \n// modification, are permitted provided that the following conditions \n// are met:\n// \n//   Redistributions of source code must retain the above copyright \n//   notice, this list of conditions and the following disclaimer.\n// \n//   Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the \n//   documentation and/or other materials provided with the   \n//   distribution.\n// \n//   Neither the name of Texas Instruments Incorporated nor the names of\n//   its contributors may be used to endorse or promote products derived\n//   from this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT \n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT \n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT \n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT \n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE \n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// $\n//###########################################################################\n\n#include \"sysctl.h\"\n#include \"dcc.h\"\n\n//\n// Define to isolate inline assembly\n//\n#define SYSCTL_DELAY        __asm(\" .if __TI_EABI__\\n\"                         \\\n                                  \" .asg    SysCtl_delay    , _SysCtl_delay\\n\" \\\n                                  \" .endif\\n\"                                  \\\n                                  \" .def _SysCtl_delay\\n\"                      \\\n                                  \" .sect \\\".TI.ramfunc\\\"\\n\"                   \\\n                                  \" .global  _SysCtl_delay\\n\"                  \\\n                                  \"_SysCtl_delay:\\n\"                           \\\n                                  \" SUB    ACC,#1\\n\"                           \\\n                                  \" BF     _SysCtl_delay, GEQ\\n\"               \\\n                                  \" LRETR\\n\")\n\n\n//\n// Macro used for adding delay between 2 consecutive writes to CLKSRCCTL1\n// register.\n// Delay = 300 NOPs\n//\n#define SYSCTL_CLKSRCCTL1_DELAY  asm(\" RPT #250 || NOP \\n RPT #50 || NOP\")\n\n//*****************************************************************************\n//\n// SysCtl_delay()\n//\n//*****************************************************************************\nSYSCTL_DELAY;\n\n\n//*****************************************************************************\n//\n// SysCtl_pollX1Counter()\n//\n//*****************************************************************************\nstatic void\nSysCtl_pollX1Counter(void)\n{\n    uint16_t loopCount = 0U;\n\n    //\n    // Delay for 1 ms while the XTAL powers up\n    //\n    // 2000 loops, 5 cycles per loop + 9 cycles overhead = 10009 cycles\n    //\n    SysCtl_delay(2000);\n\n    //\n    // Clear and saturate X1CNT 4 times to guarantee operation\n    //\n    do\n    {\n        //\n        // Keep clearing the counter until it is no longer saturated\n        //\n        while(HWREG(CLKCFG_BASE + SYSCTL_O_X1CNT) > 0x1FFU)\n        {\n            HWREG(CLKCFG_BASE + SYSCTL_O_X1CNT) |= SYSCTL_X1CNT_CLR;\n        }\n\n        //\n        // Wait for the X1 clock to saturate\n        //\n        while(HWREGH(CLKCFG_BASE + SYSCTL_O_X1CNT) != SYSCTL_X1CNT_X1CNT_M)\n        {\n            //\n            // If your application is stuck in this loop, please check if the\n            // input clock source is valid.\n            //\n        }\n\n        //\n        // Increment the counter\n        //\n        loopCount++;\n    }while(loopCount < 4U);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getClock(uint32_t clockInHz)\n{\n    uint32_t temp;\n    uint32_t oscSource;\n    uint32_t clockOut;\n\n    //\n    // Don't proceed if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning the INTOSC1 rate. You need\n        // to handle the MCD and clear the failure.\n        //\n        clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n    }\n    else\n    {\n        //\n        // If one of the internal oscillators is being used, start from the\n        // known default frequency.  Otherwise, use clockInHz parameter.\n        //\n        oscSource = HWREG(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    (uint32_t)SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n        if((oscSource == ((uint32_t)SYSCTL_OSCSRC_OSC2 >> SYSCTL_OSCSRC_S)) ||\n           (oscSource == ((uint32_t)SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S)))\n        {\n            clockOut = SYSCTL_DEFAULT_OSC_FREQ;\n        }\n        else\n        {\n            clockOut = clockInHz;\n        }\n\n        //\n        // If the PLL is enabled calculate its effect on the clock\n        //\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &\n            (SYSCTL_SYSPLLCTL1_PLLEN | SYSCTL_SYSPLLCTL1_PLLCLKEN)) == 3U)\n        {\n            //\n            // Calculate portion from fractional multiplier\n            //\n            temp = (clockInHz * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                  SYSCTL_SYSPLLMULT_FMULT_M) >>\n                                 SYSCTL_SYSPLLMULT_FMULT_S)) / 4U;\n\n            //\n            // Calculate integer multiplier and fixed divide by 2\n            //\n            clockOut = clockOut * ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                    SYSCTL_SYSPLLMULT_IMULT_M) >>\n                                   SYSCTL_SYSPLLMULT_IMULT_S);\n\n            //\n            // Add in fractional portion\n            //\n            clockOut += temp;\n\n            //\n            // Calculate PLL divider\n            //\n            temp = ((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                     SYSCTL_SYSPLLMULT_ODIV_M) >>\n                    SYSCTL_SYSPLLMULT_ODIV_S) + 1U;\n\n            //\n            //  Divide dividers\n            //\n            if(temp != 0U)\n            {\n                clockOut /= temp;\n            }\n        }\n\n        if((HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n            SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) != 0U)\n        {\n            clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                               SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M));\n        }\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_setClock()\n//\n//*****************************************************************************\nbool\nSysCtl_setClock(uint32_t config)\n{\n    uint16_t divSel;\n    uint32_t pllMult;\n    uint32_t retries, oscSource, pllLockStatus;\n    uint32_t timeout;\n    bool status = false;\n    uint32_t mult;\n\n    //\n    // Check the arguments.\n    //\n    ASSERT((config & SYSCTL_OSCSRC_M) <= SYSCTL_OSCSRC_M);\n\n    //\n    // Don't proceed to the PLL initialization if an MCD failure is detected.\n    //\n    if(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // OSCCLKSRC2 failure detected. Returning false. You'll need to clear\n        // the MCD error.\n        //\n        status = false;\n    }\n    else\n    {\n        //\n        // Configure oscillator source\n        //\n        oscSource = config & SYSCTL_OSCSRC_M;\n        SysCtl_selectOscSource(oscSource);\n\n        //\n        // Bypass PLL\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n            ~SYSCTL_SYSPLLCTL1_PLLCLKEN;\n        EDIS;\n\n        //\n        // Delay of at least 60 OSCCLK cycles required post PLL bypass\n        //\n        SysCtl_delay(11U);\n\n        //\n        // Get the PLL multiplier settings from config\n        //\n        pllMult  = (uint32_t)((config & SYSCTL_IMULT_M) <<\n                              SYSCTL_SYSPLLMULT_IMULT_S);\n\n        pllMult |= (uint32_t)(((config & SYSCTL_FMULT_M) >> SYSCTL_FMULT_S) <<\n                              SYSCTL_SYSPLLMULT_FMULT_S);\n\n        pllMult |= (uint32_t)(((config & SYSCTL_ODIV_M) >> SYSCTL_ODIV_S) <<\n                              SYSCTL_SYSPLLMULT_ODIV_S);\n\n        //\n        // Get the PLL multipliers currently programmed\n        //\n        mult  = (uint32_t)((HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                            (uint32_t)SYSCTL_SYSPLLMULT_IMULT_M) >>\n                           (uint32_t)SYSCTL_SYSPLLMULT_IMULT_S);\n\n        mult |= (uint32_t)(HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                                 SYSCTL_SYSPLLMULT_FMULT_M);\n\n        mult |= (uint32_t)(HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) &\n                           SYSCTL_SYSPLLMULT_ODIV_M);\n\n        //\n        // Lock PLL only if the multipliers need update\n        //\n        if(mult !=  pllMult)\n        {\n            //\n            // Configure PLL if enabled\n            //\n            if((config & SYSCTL_PLL_ENABLE) == SYSCTL_PLL_ENABLE)\n            {\n                //\n                // Set dividers to /1\n                //\n                EALLOW;\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) = 0U;\n                EDIS;\n\n                //\n                // Loop to retry locking the PLL should the DCC module\n                // indicate that it was not successful.\n                //\n                for(retries = 0U; (retries < SYSCTL_PLL_RETRIES); retries++)\n                {\n                    //\n                    // Turn off PLL\n                    //\n                    EALLOW;\n                    HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) &=\n                        ~SYSCTL_SYSPLLCTL1_PLLEN;\n\n                    SysCtl_delay(3U);\n\n                    //\n                    // Write multiplier, which automatically turns on the PLL\n                    //\n                    HWREG(CLKCFG_BASE + SYSCTL_O_SYSPLLMULT) = pllMult;\n\n                    //\n                    // Wait for the SYSPLL lock counter or a timeout\n                    //\n                    timeout = SYSCTL_PLLLOCK_TIMEOUT;\n                    pllLockStatus = HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLSTS) &\n                                    SYSCTL_SYSPLLSTS_LOCKS;\n\n                    while((pllLockStatus != 1U) && (timeout != 0U))\n                    {\n                        pllLockStatus = HWREGH(CLKCFG_BASE +\n                                               SYSCTL_O_SYSPLLSTS) &\n                                        SYSCTL_SYSPLLSTS_LOCKS;\n                        timeout--;\n                    }\n                    EDIS;\n\n                    //\n                    // Check PLL Frequency using DCC\n                    //\n                    status = SysCtl_isPLLValid(oscSource,\n                                              (config &\n                                              ((uint32_t)SYSCTL_IMULT_M |\n                                               (uint32_t)SYSCTL_FMULT_M |\n                                               (uint32_t)SYSCTL_ODIV_M)));\n\n                    //\n                    // Check DCC Status, if no error break the loop\n                    //\n                    if(status)\n                    {\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                status = true;\n            }\n        }\n      else\n        {\n            status = true;\n        }\n\n\n        //\n        // If PLL locked successfully, configure the dividers\n        //\n        if(status)\n        {\n            //\n            // Set divider to produce slower output frequency to limit current\n            // increase.\n            //\n            divSel = (uint16_t)(config & SYSCTL_SYSDIV_M) >> SYSCTL_SYSDIV_S;\n\n            EALLOW;\n            if(divSel != (126U / 2U))\n            {\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                     ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) |\n                    (divSel + 1U);\n            }\n            else\n            {\n                HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                    (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                     ~(uint16_t)SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n            }\n\n            EDIS;\n\n            //\n            // Enable PLLSYSCLK is fed from system PLL clock\n            //\n            EALLOW;\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSPLLCTL1) |=\n                SYSCTL_SYSPLLCTL1_PLLCLKEN;\n            EDIS;\n\n            //\n            // ~200 PLLSYSCLK delay to allow voltage regulator to stabilize\n            // prior to increasing entire system clock frequency.\n            //\n            SysCtl_delay(40U);\n\n            //\n            // Set the divider to user value\n            //\n            EALLOW;\n            HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) =\n                (HWREGH(CLKCFG_BASE + SYSCTL_O_SYSCLKDIVSEL) &\n                 ~SYSCTL_SYSCLKDIVSEL_PLLSYSCLKDIV_M) | divSel;\n            EDIS;\n        }\n    }\n\n    return(status);\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectXTAL()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectXTAL(void)\n{\n    EALLOW;\n\n    //\n    // Turn on XTAL and select crystal mode\n    //\n    HWREGH(CLKCFG_BASE + SYSCTL_O_XTALCR) &= ~SYSCTL_XTALCR_OSCOFF;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_XTALCR) &= ~SYSCTL_XTALCR_SE;\n    EDIS;\n\n    //\n    // Wait for the X1 clock to saturate\n    //\n    SysCtl_pollX1Counter();\n\n    //\n    // Select XTAL as the oscillator source\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n    ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n      (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n     ((uint32_t)SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n    EDIS;\n\n    //\n    // If a missing clock failure was detected, try waiting for the X1 counter\n    // to saturate again. Consider modifying this code to add a 10ms timeout.\n    //\n    while(SysCtl_isMCDClockFailureDetected())\n    {\n        //\n        // Clear the MCD failure\n        //\n        SysCtl_resetMCD();\n\n        //\n        // Wait for the X1 clock to saturate\n        //\n        SysCtl_pollX1Counter();\n\n        //\n        // Select XTAL as the oscillator source\n        //\n        EALLOW;\n        HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n        ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n          (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n         ((uint32_t)SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n        EDIS;\n    }\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectXTALSingleEnded()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectXTALSingleEnded(void)\n{\n    //\n    // Turn on XTAL and select single-ended mode.\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_XTALCR) &= ~SYSCTL_XTALCR_OSCOFF;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_XTALCR) |= SYSCTL_XTALCR_SE;\n    EDIS;\n\n    //\n    // Wait for the X1 clock to saturate\n    //\n    SysCtl_pollX1Counter();\n\n    //\n    // Select XTAL as the oscillator source\n    //\n    EALLOW;\n    HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n    ((HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n      (~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M)) |\n     ((uint32_t)SYSCTL_OSCSRC_XTAL >> SYSCTL_OSCSRC_S));\n    EDIS;\n\n    //\n    // Something is wrong with the oscillator module. Replace the ESTOP0 with\n    // an appropriate error-handling routine.\n    //\n    while(SysCtl_isMCDClockFailureDetected())\n    {\n        ESTOP0;\n    }\n}\n\n//*****************************************************************************\n//\n// SysCtl_selectOscSource()\n//\n//*****************************************************************************\nvoid\nSysCtl_selectOscSource(uint32_t oscSource)\n{\n    ASSERT((oscSource == SYSCTL_OSCSRC_OSC1) |\n           (oscSource == SYSCTL_OSCSRC_OSC2) |\n           (oscSource == SYSCTL_OSCSRC_XTAL) |\n           (oscSource == SYSCTL_OSCSRC_XTAL_SE));\n\n    //\n    // Select the specified source.\n    //\n    EALLOW;\n    switch(oscSource)\n    {\n        case SYSCTL_OSCSRC_OSC2:\n            //\n            // Turn on INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_INTOSC2OFF;\n\n            SYSCTL_CLKSRCCTL1_DELAY;\n\n            //\n            // Clk Src = INTOSC2\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &=\n                ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M;\n\n            break;\n\n        case SYSCTL_OSCSRC_XTAL:\n            //\n            // Select XTAL in crystal mode and wait for it to power up\n            //\n            SysCtl_selectXTAL();\n            break;\n\n        case SYSCTL_OSCSRC_XTAL_SE:\n            //\n            // Select XTAL in single-ended mode and wait for it to power up\n            //\n            SysCtl_selectXTALSingleEnded();\n            break;\n\n        case SYSCTL_OSCSRC_OSC1:\n            //\n            // Clk Src = INTOSC1\n            //\n            HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) =\n                   (HWREGH(CLKCFG_BASE + SYSCTL_O_CLKSRCCTL1) &\n                    ~SYSCTL_CLKSRCCTL1_OSCCLKSRCSEL_M) |\n                   ((uint32_t)SYSCTL_OSCSRC_OSC1 >> SYSCTL_OSCSRC_S);\n\n            break;\n\n        default:\n            //\n            // Do nothing. Not a valid oscSource value.\n            //\n            break;\n    }\n    EDIS;\n}\n\n//*****************************************************************************\n//\n// SysCtl_getLowSpeedClock()\n//\n//*****************************************************************************\nuint32_t\nSysCtl_getLowSpeedClock(uint32_t clockInHz)\n{\n    uint32_t clockOut;\n\n    //\n    // Get the main system clock\n    //\n    clockOut = SysCtl_getClock(clockInHz);\n\n    //\n    // Apply the divider to the main clock\n    //\n    if((HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n        SYSCTL_LOSPCP_LSPCLKDIV_M) != 0U)\n    {\n        clockOut /= (2U * (HWREG(CLKCFG_BASE + SYSCTL_O_LOSPCP) &\n                            SYSCTL_LOSPCP_LSPCLKDIV_M));\n    }\n\n    return(clockOut);\n}\n\n//*****************************************************************************\n//\n// SysCtl_getDeviceParametric()\n//\n//*****************************************************************************\nuint16_t\nSysCtl_getDeviceParametric(SysCtl_DeviceParametric parametric)\n{\n    uint32_t value;\n\n    //\n    // Get requested parametric value\n    //\n    switch(parametric)\n    {\n        case SYSCTL_DEVICE_QUAL:\n            //\n            // Qualification Status\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_QUAL_M) >> SYSCTL_PARTIDL_QUAL_S);\n            break;\n\n        case SYSCTL_DEVICE_PINCOUNT:\n            //\n            // Pin Count\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_PIN_COUNT_M) >>\n                     SYSCTL_PARTIDL_PIN_COUNT_S);\n            break;\n\n        case SYSCTL_DEVICE_INSTASPIN:\n            //\n            // InstaSPIN Feature Set\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_INSTASPIN_M) >>\n                     SYSCTL_PARTIDL_INSTASPIN_S);\n            break;\n\n        case SYSCTL_DEVICE_FLASH:\n            //\n            // Flash Size (KB)\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDL) &\n                      SYSCTL_PARTIDL_FLASH_SIZE_M) >>\n                     SYSCTL_PARTIDL_FLASH_SIZE_S);\n            break;\n\n        case SYSCTL_DEVICE_FAMILY:\n            //\n            // Device Family\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_FAMILY_M) >> SYSCTL_PARTIDH_FAMILY_S);\n            break;\n\n        case SYSCTL_DEVICE_PARTNO:\n            //\n            // Part Number\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_PARTNO_M) >> SYSCTL_PARTIDH_PARTNO_S);\n            break;\n\n        case SYSCTL_DEVICE_CLASSID:\n            //\n            // Class ID\n            //\n            value = ((HWREG(DEVCFG_BASE + SYSCTL_O_PARTIDH) &\n                      SYSCTL_PARTIDH_DEVICE_CLASS_ID_M) >>\n                     SYSCTL_PARTIDH_DEVICE_CLASS_ID_S);\n            break;\n\n        default:\n            //\n            // Not a valid value for PARTID register\n            //\n            value = 0U;\n            break;\n    }\n\n    return((uint16_t)value);\n}\n//*****************************************************************************\n//\n// SysCtl_isPLLValid()\n//\n//*****************************************************************************\nbool\nSysCtl_isPLLValid(uint32_t oscSource, uint32_t pllMultDiv)\n{\n    uint32_t imult, fmult, odiv, base;\n\n    DCC_Count0ClockSource dccClkSrc0;\n    DCC_Count1ClockSource dccClkSrc1;\n    uint32_t dccCounterSeed0, dccCounterSeed1, dccValidSeed0;\n\n    switch(oscSource)\n    {\n        case SYSCTL_OSCSRC_OSC2:\n            //\n            // Select DCC Clk Src0 as INTOSC2\n            //\n            dccClkSrc0 = DCC_COUNT0SRC_INTOSC2;\n            break;\n        case SYSCTL_OSCSRC_XTAL:\n        case SYSCTL_OSCSRC_XTAL_SE:\n            //\n            // Select DCC Clk Src0 as XTAL\n            //\n            dccClkSrc0 = DCC_COUNT0SRC_XTAL;\n            break;\n        case SYSCTL_OSCSRC_OSC1:\n            //\n            // Select DCC Clk Src0 as INTOSC1\n            //\n            dccClkSrc0 = DCC_COUNT0SRC_INTOSC1;\n            break;\n        default:\n            //\n            // Select DCC Clk Src0 as INTOSC1\n            //\n            dccClkSrc0 = DCC_COUNT0SRC_INTOSC1;\n            break;\n    }\n\n    //\n    // Setting Counter0 & Valid Seed Value with +/-12% tolerance\n    //\n    dccCounterSeed0 = (uint32_t)SYSCTL_DCC_COUNTER0_WINDOW - 12U;\n    dccValidSeed0 = 24U;\n\n    //\n    // Select DCC0 for PLL validation\n    //\n    base = DCC0_BASE;\n\n    //\n    // Select DCC Clk Src1 as SYSPLL\n    //\n    dccClkSrc1 = DCC_COUNT1SRC_PLL;\n\n    imult = pllMultDiv & SYSCTL_IMULT_M;\n    fmult = pllMultDiv & SYSCTL_FMULT_M;\n    odiv = (pllMultDiv & SYSCTL_ODIV_M) >> SYSCTL_ODIV_S;\n\n    //\n    // Multiplying Counter-0 window with PLL Integer Multiplier\n    //\n    dccCounterSeed1 = SYSCTL_DCC_COUNTER0_WINDOW * imult / (odiv + 1U);\n\n    //\n    // Multiplying Counter-0 window with PLL Fractional Multiplier\n    //\n    switch(fmult)\n    {\n        case SYSCTL_FMULT_1_4:\n            //\n            // FMULT * CNTR0 Window = 0.25 * 100 = 25, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 25U;\n            break;\n        case SYSCTL_FMULT_1_2:\n            //\n            // FMULT * CNTR0 Window = 0.5 * 100 = 50, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 50U;\n            break;\n        case SYSCTL_FMULT_3_4:\n            //\n            // FMULT * CNTR0 Window = 0.75 * 100 = 75, gets added to cntr0\n            // seed value\n            //\n            dccCounterSeed1 = dccCounterSeed1 + 75U;\n            break;\n        default:\n            //\n            // No fractional multiplier\n            //\n            dccCounterSeed1 = dccCounterSeed1;\n            break;\n    }\n\n\n    //\n    // Enable peripheral clock to DCC\n    //\n    SysCtl_enablePeripheral(SYSCTL_PERIPH_CLK_DCC0);\n\n    //\n    // Clear Error & Done Flag\n    //\n    DCC_clearErrorFlag(base);\n    DCC_clearDoneFlag(base);\n\n    //\n    // Disable DCC\n    //\n    DCC_disableModule(base);\n\n    //\n    // Disable Error Signal\n    //\n    DCC_disableErrorSignal(base);\n\n    //\n    // Disable Done Signal\n    //\n    DCC_disableDoneSignal(base);\n\n    //\n    // Configure Clock Source0 to whatever set as a clock source for PLL\n    //\n    DCC_setCounter0ClkSource(base, dccClkSrc0);\n\n    //\n    // Configure Clock Source1 to PLL\n    //\n    DCC_setCounter1ClkSource(base, dccClkSrc1);\n\n    //\n    // Configure COUNTER-0, COUNTER-1 & Valid Window\n    //\n    DCC_setCounterSeeds(base, dccCounterSeed0, dccValidSeed0,\n                        dccCounterSeed1);\n\n    //\n    // Enable Single Shot mode\n    //\n    DCC_enableSingleShotMode(base, DCC_MODE_COUNTER_ZERO);\n\n    //\n    // Enable Error Signal\n    //\n    DCC_enableErrorSignal(base);\n\n    //\n    // Enable Done Signal\n    //\n    DCC_enableDoneSignal(base);\n\n    //\n    // Enable DCC to start counting\n    //\n    DCC_enableModule(base);\n\n    //\n    // Timeout for the loop\n    //\n    uint32_t timeout = dccCounterSeed1;\n\n    //\n    // Wait until Error or Done Flag is generated\n    //\n    while(((HWREGH(base + DCC_O_STATUS) &\n            (DCC_STATUS_ERR | DCC_STATUS_DONE)) == 0U) && (timeout != 0U))\n\n    {\n        timeout--;\n    }\n\n\n    //\n    // Returns true if DCC completes without error\n    //\n\n    return(((HWREGH(base + DCC_O_STATUS) &\n             (DCC_STATUS_ERR | DCC_STATUS_DONE)) == DCC_STATUS_DONE) &&\n            (HWREGH(base + DCC_O_CNT0) == 0U) &&\n            (HWREGH(base + DCC_O_VALID0) == 0U) &&\n            (HWREGH(base + DCC_O_CNT1) == 0U));\n}\n\n"}],"trace":"{\"model\":\"RealTimeMachine\",\"sources\":[\"RealTimeMachine.c\",\"RealTimeMachine.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\",\"LocalParameters\"],\"sidPrefixes\":[\"RealTimeMachine\"],\"fileRecords\":{\"1\":{\"records\":[{\"tk\":[40,3,40,11],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[40,12,40,20],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[40,20,40,21],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,3,41,11],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,12,41,15],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,15,41,16],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[42,3,42,11],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[42,12,42,18],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[42,18,42,19],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[47,3,47,9],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[47,10,47,17],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[47,17,47,18],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[48,3,48,11],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[48,12,48,26],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[48,26,48,27],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[49,3,49,11],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[49,12,49,22],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[49,22,49,23],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[50,3,50,11],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[50,12,50,40],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[50,40,50,41],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[51,3,51,11],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[51,12,51,33],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[51,33,51,34],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[52,3,52,11],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[52,12,52,28],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[52,28,52,29],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,3,57,13],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,14,57,37],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,37,57,38],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,38,57,39],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,39,57,40],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[57,40,57,41],\"els\":[\"1:58\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,3,58,13],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,14,58,28],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,28,58,29],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,29,58,30],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,30,58,31],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[58,31,58,32],\"els\":[\"1:20\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[63,3,63,11],\"els\":[\"1:59\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[63,12,63,26],\"els\":[\"1:59\"],\"ct\":{\"1\":1,\"0\":2}},{\"tk\":[63,26,63,27],\"els\":[\"1:59\"],\"ct\":{\"1\":1,\"0\":2}}]},\"0\":{\"records\":[{\"tk\":[51,3,51,5],\"els\":[\"0:20\"]},{\"tk\":[53,5,53,23],\"els\":[\"0:20\"]},{\"tk\":[53,24,53,52],\"els\":[\"0:20\"]},{\"tk\":[53,53,53,54],\"els\":[\"0:20\"]},{\"tk\":[53,55,53,57],\"els\":[\"0:20\"]},{\"tk\":[57,5,57,23],\"els\":[\"0:20:1\",\"0:20\"]},{\"tk\":[57,24,57,45],\"els\":[\"0:20:1\",\"0:20\"]},{\"tk\":[57,46,57,47],\"els\":[\"0:20:1\",\"0:20\"]},{\"tk\":[57,48,57,72],\"els\":[\"0:20:1\",\"0:20\"]},{\"tk\":[60,5,60,22],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[60,23,60,29],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[60,30,60,31],\"els\":[\"0:20::156#out:2\",\"0:20:1\",\"0:20\"]},{\"tk\":[60,32,60,34],\"els\":[\"0:20:1\",\"0:20\"]},{\"tk\":[64,5,64,7],\"els\":[\"0:20:101\",\"0:20:2\"]},{\"tk\":[64,9,64,27],\"els\":[\"0:20:101\",\"0:20:2\"]},{\"tk\":[64,28,64,44],\"els\":[\"0:20:101\",\"0:20:2\"]},{\"tk\":[64,45,64,47],\"els\":[\"0:20:101\",\"0:20:2\"]},{\"tk\":[64,48,64,50],\"els\":[\"0:20:101\",\"0:20:2\"]},{\"tk\":[66,7,66,9],\"els\":[\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[66,11,66,28],\"els\":[\"0:59\"]},{\"tk\":[66,29,66,43],\"els\":[\"0:59\"]},{\"tk\":[66,44,66,46],\"els\":[\"0:20:104\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[66,47,66,49],\"els\":[\"0:20:104\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[68,9,68,27],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[68,28,68,44],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[68,45,68,46],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[68,47,68,73],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[71,9,71,26],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[71,27,71,33],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[71,34,71,35],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[71,36,71,38],\"els\":[\"0:20:98\",\"0:20:100\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[75,12,75,14],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[75,16,75,33],\"els\":[\"0:59\"]},{\"tk\":[75,34,75,48],\"els\":[\"0:59\"]},{\"tk\":[75,49,75,51],\"els\":[\"0:20:103\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[75,52,75,54],\"els\":[\"0:20:103\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[77,7,77,25],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[77,26,77,42],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[77,43,77,44],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[77,45,77,72],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[80,7,80,24],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[80,25,80,31],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[80,32,80,33],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[80,34,80,36],\"els\":[\"0:20:100\",\"0:20:98\",\"0:20:101\",\"0:20:2\"]},{\"tk\":[84,10,84,12],\"els\":[\"0:20:1\"]},{\"tk\":[84,14,84,15],\"els\":[\"0:20:9\",\"0:20:1\"]},{\"tk\":[84,15,84,22],\"els\":[\"0:20:9\",\"0:20:1\"]},{\"tk\":[84,23,84,25],\"els\":[\"0:20:9\",\"0:20:1\"]},{\"tk\":[84,26,84,51],\"els\":[\"0:20:9\",\"0:20:1\"]},{\"tk\":[86,5,86,23],\"els\":[\"0:20:2\",\"0:20:1\"]},{\"tk\":[86,24,86,45],\"els\":[\"0:20:2\",\"0:20:1\"]},{\"tk\":[86,46,86,47],\"els\":[\"0:20:2\",\"0:20:1\"]},{\"tk\":[86,48,86,71],\"els\":[\"0:20:2\",\"0:20:1\"]},{\"tk\":[91,5,91,23],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[91,24,91,40],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[91,41,91,42],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[91,43,91,69],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[94,5,94,22],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[94,23,94,29],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[94,30,94,31],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[94,32,94,34],\"els\":[\"0:20:98\",\"0:20:101\",\"0:20:2\",\"0:20:1\"]},{\"tk\":[96,5,96,22],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[96,23,96,29],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[96,30,96,31],\"els\":[\"0:20:1\"]},{\"tk\":[96,32,96,34],\"els\":[\"0:20:1\"]},{\"tk\":[120,3,120,16],\"els\":[\"0:58::38\"]},{\"tk\":[120,17,120,18],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[120,22,120,40],\"els\":[\"0:22\"]},{\"tk\":[120,40,120,41],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[120,41,120,42],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[120,44,120,45],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[120,46,120,48],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[120,50,120,52],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,22,121,45],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,46,121,60],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,60,121,61],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,61,121,62],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,64,121,66],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,67,121,76],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[121,79,121,81],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[122,21,122,44],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[122,45,122,59],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[122,59,122,60],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[122,60,122,61],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[122,63,122,65],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[123,21,123,40],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[124,11,124,12],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[124,16,124,34],\"els\":[\"0:22\"]},{\"tk\":[124,34,124,35],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[124,35,124,36],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[124,38,124,39],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[124,40,124,42],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[124,44,124,46],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,16,125,39],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,40,125,54],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,54,125,55],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,55,125,56],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,58,125,60],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,61,125,70],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[125,73,125,75],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,15,126,38],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,39,126,53],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,53,126,54],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,54,126,55],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,57,126,59],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[126,60,126,79],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[127,3,127,5],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[127,7,127,20],\"els\":[\"0:58::38\"]},{\"tk\":[127,21,127,23],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,5,129,10],\"els\":[\"0:20::110\"]},{\"tk\":[129,11,129,12],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,13,129,14],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,23,129,36],\"els\":[\"0:58::38\"]},{\"tk\":[129,37,129,38],\"els\":[\"0:58::38\"]},{\"tk\":[129,39,129,40],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,48,129,66],\"els\":[\"0:22\"]},{\"tk\":[129,66,129,67],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[129,67,129,68],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[129,70,129,71],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,72,129,73],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[129,74,129,75],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[130,23,130,37],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[130,40,130,55],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[130,58,130,68],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,5,131,8],\"els\":[\"0:20::110\"]},{\"tk\":[131,9,131,10],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,11,131,12],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,31,131,32],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,40,131,58],\"els\":[\"0:22\"]},{\"tk\":[131,58,131,59],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[131,59,131,60],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[131,62,131,63],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,64,131,65],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[131,66,131,67],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[132,21,132,35],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[132,38,132,53],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[132,56,132,66],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,5,135,7],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[135,11,135,16],\"els\":[\"0:20::110\"]},{\"tk\":[135,17,135,18],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,19,135,23],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,25,135,27],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,28,135,30],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,31,135,32],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,33,135,38],\"els\":[\"0:20::110\"]},{\"tk\":[135,39,135,40],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,41,135,42],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,48,135,53],\"els\":[\"0:20::110\"]},{\"tk\":[135,54,135,55],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,56,135,59],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[135,61,135,63],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[135,64,135,65],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[137,7,137,14],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[137,15,137,16],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[137,17,137,43],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[138,7,138,38],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[138,38,138,39],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[138,39,138,40],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[138,40,138,47],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[138,47,138,48],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[141,5,141,7],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[141,11,141,14],\"els\":[\"0:20::110\"]},{\"tk\":[141,15,141,16],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,17,141,21],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,23,141,25],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,26,141,28],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,29,141,30],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,31,141,34],\"els\":[\"0:20::110\"]},{\"tk\":[141,35,141,36],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,37,141,38],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,44,141,47],\"els\":[\"0:20::110\"]},{\"tk\":[141,48,141,49],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,50,141,53],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[141,55,141,57],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[141,58,141,59],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[143,7,143,14],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[143,15,143,16],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[143,17,143,42],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[144,7,144,38],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[144,38,144,39],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[144,39,144,40],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[144,40,144,47],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[144,47,144,48],\"els\":[\"0:20::156\",\"0:20::110\",\"0:20\"]},{\"tk\":[149,3,149,26],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[149,27,149,41],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[149,41,149,42],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[149,42,149,43],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[149,45,149,46],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[149,60,149,78],\"els\":[\"0:22\"]},{\"tk\":[149,78,149,79],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[149,79,149,80],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[150,5,150,6],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[150,7,150,9],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[155,3,155,16],\"els\":[\"0:58::38\"]},{\"tk\":[155,17,155,18],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[155,22,155,40],\"els\":[\"0:22\"]},{\"tk\":[155,40,155,41],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[155,41,155,42],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[155,44,155,45],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[155,46,155,48],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[155,50,155,52],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[156,22,156,45],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[156,46,156,69],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[156,69,156,70],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[156,70,156,71],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[156,73,156,75],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[157,22,157,31],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[157,34,157,36],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[158,21,158,44],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[158,45,158,68],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[158,68,158,69],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[158,69,158,70],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[158,72,158,74],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[159,21,159,40],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[164,3,164,26],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[164,27,164,41],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[164,41,164,42],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[164,42,164,43],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[164,45,164,46],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[164,60,164,78],\"els\":[\"0:22\"]},{\"tk\":[164,78,164,79],\"els\":[\"0:22\",\"0:20::110\",\"0:20\"]},{\"tk\":[164,79,164,80],\"els\":[\"0:20::110\",\"0:20\",\"0:22\"]},{\"tk\":[165,5,165,6],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[165,7,165,9],\"els\":[\"0:20::110\",\"0:20\"]},{\"tk\":[170,11,170,12],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[170,16,170,34],\"els\":[\"0:22\"]},{\"tk\":[170,34,170,35],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[170,35,170,36],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[170,38,170,39],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[170,40,170,42],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[170,44,170,46],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,16,171,39],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,40,171,63],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,63,171,64],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,64,171,65],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,67,171,69],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[171,70,171,79],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,14,172,16],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,18,172,41],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,42,172,65],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,65,172,66],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,66,172,67],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[172,69,172,71],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[173,18,173,37],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[174,3,174,5],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[174,7,174,20],\"els\":[\"0:58::38\"]},{\"tk\":[174,21,174,23],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,5,176,10],\"els\":[\"0:20::110\"]},{\"tk\":[176,11,176,12],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,13,176,14],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,23,176,36],\"els\":[\"0:58::38\"]},{\"tk\":[176,37,176,38],\"els\":[\"0:58::38\"]},{\"tk\":[176,39,176,40],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,48,176,66],\"els\":[\"0:22\"]},{\"tk\":[176,66,176,67],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[176,67,176,68],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[176,70,176,71],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,72,176,73],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[176,74,176,75],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[177,23,177,37],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[177,40,177,55],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[177,58,177,68],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,5,178,8],\"els\":[\"0:20::110\"]},{\"tk\":[178,9,178,10],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,11,178,12],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,31,178,32],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,40,178,58],\"els\":[\"0:22\"]},{\"tk\":[178,58,178,59],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[178,59,178,60],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[178,62,178,63],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,64,178,65],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[178,66,178,67],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[179,21,179,35],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[179,38,179,53],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[179,56,179,66],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,5,180,7],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[180,11,180,16],\"els\":[\"0:20::110\"]},{\"tk\":[180,17,180,18],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,19,180,23],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,25,180,27],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,28,180,30],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,31,180,32],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,33,180,38],\"els\":[\"0:20::110\"]},{\"tk\":[180,39,180,40],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,41,180,42],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,48,180,53],\"els\":[\"0:20::110\"]},{\"tk\":[180,54,180,55],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,56,180,59],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[180,61,180,63],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[180,64,180,65],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[196,7,196,9],\"els\":[\"0:58:676-1961\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[196,12,196,26],\"els\":[\"0:24\"]},{\"tk\":[196,27,196,29],\"els\":[\"0:58:680-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[196,30,196,48],\"els\":[\"0:58:694-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[196,49,196,63],\"els\":[\"0:58:694-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[196,65,196,67],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[197,12,197,29],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[197,30,197,36],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[197,37,197,39],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[197,40,197,42],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[202,9,202,19],\"els\":[\"0:58:936-946\"]},{\"tk\":[202,20,202,21],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58:1525-1552\"]},{\"tk\":[202,22,202,36],\"els\":[\"0:24\"]},{\"tk\":[202,37,202,38],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[203,11,203,29],\"els\":[\"0:58:898-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[203,30,203,44],\"els\":[\"0:58:898-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[204,9,204,11],\"els\":[\"0:58:885-912\"]},{\"tk\":[204,12,204,13],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[204,14,204,24],\"els\":[\"0:58:936-946\"]},{\"tk\":[205,9,205,11],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[205,13,205,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[205,24,205,25],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[205,26,205,40],\"els\":[\"0:24\"]},{\"tk\":[206,11,206,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[206,14,206,15],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[206,16,206,19],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,9,209,11],\"els\":[\"0:58:847-1701\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,14,209,28],\"els\":[\"0:24\"]},{\"tk\":[209,29,209,30],\"els\":[\"0:58:851-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,31,209,49],\"els\":[\"0:58:864-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,50,209,64],\"els\":[\"0:58:864-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,66,209,68],\"els\":[\"0:58:884-926\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[209,70,209,72],\"els\":[\"0:58:885-912\"]},{\"tk\":[209,73,209,74],\"els\":[\"0:58:884-926\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[210,14,210,23],\"els\":[\"0:58:917-925\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[212,11,212,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[212,14,212,15],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[212,16,212,26],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[212,27,212,28],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[212,44,212,58],\"els\":[\"0:24\"]},{\"tk\":[213,11,213,13],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[213,15,213,25],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[213,26,213,27],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[213,28,213,42],\"els\":[\"0:24\"]},{\"tk\":[213,43,213,44],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[213,45,213,55],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[214,13,214,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[214,16,214,17],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[214,18,214,21],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[217,11,217,21],\"els\":[\"0:58:936-946\"]},{\"tk\":[217,22,217,23],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[217,24,217,26],\"els\":[\"0:58:885-912\"]},{\"tk\":[217,27,217,28],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[217,44,217,62],\"els\":[\"0:58:973-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[217,63,217,77],\"els\":[\"0:58:973-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[218,11,218,13],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[218,15,218,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[218,26,218,27],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[218,28,218,30],\"els\":[\"0:58:885-912\"]},{\"tk\":[219,13,219,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[219,24,219,25],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[219,26,219,38],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[223,11,223,29],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[223,30,223,44],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[223,45,223,46],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[223,47,223,61],\"els\":[\"0:24\"]},{\"tk\":[226,11,226,29],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[226,30,226,40],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[226,41,226,42],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[226,43,226,45],\"els\":[\"0:58:1047-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[228,11,228,17],\"els\":[\"0:58:1112-1139\"]},{\"tk\":[228,18,228,19],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58:1356-1383\"]},{\"tk\":[228,20,228,38],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[228,39,228,53],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[228,54,228,55],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[229,13,229,27],\"els\":[\"0:24\"]},{\"tk\":[230,11,230,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[230,14,230,15],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[230,16,230,22],\"els\":[\"0:58:1112-1139\"]},{\"tk\":[231,11,231,13],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[231,15,231,21],\"els\":[\"0:58:1112-1139\"]},{\"tk\":[231,22,231,23],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[231,24,231,42],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[231,43,231,57],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[232,13,232,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[232,16,232,17],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[232,18,232,21],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,11,235,13],\"els\":[\"0:58:1071-1294\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,16,235,30],\"els\":[\"0:24\"]},{\"tk\":[235,31,235,32],\"els\":[\"0:58:1078-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,33,235,51],\"els\":[\"0:58:1091-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,52,235,66],\"els\":[\"0:58:1091-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,68,235,70],\"els\":[\"0:58:1111-1153\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[235,72,235,74],\"els\":[\"0:58:885-912\"]},{\"tk\":[235,75,235,76],\"els\":[\"0:58:1111-1153\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[236,16,236,25],\"els\":[\"0:58:1144-1152\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[239,13,239,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[239,16,239,17],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[239,18,239,28],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[239,29,239,30],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[239,46,239,64],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[239,65,239,79],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,13,240,15],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,17,240,27],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,28,240,29],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,30,240,48],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,49,240,63],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,64,240,65],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[240,66,240,76],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[241,15,241,17],\"els\":[\"0:58:885-912\"]},{\"tk\":[241,18,241,19],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[241,20,241,23],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[244,13,244,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[244,24,244,25],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[244,26,244,28],\"els\":[\"0:58:885-912\"]},{\"tk\":[244,29,244,30],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[244,46,244,60],\"els\":[\"0:24\"]},{\"tk\":[245,13,245,15],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[245,17,245,27],\"els\":[\"0:58:936-946\"]},{\"tk\":[245,28,245,29],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[245,30,245,32],\"els\":[\"0:58:885-912\"]},{\"tk\":[246,15,246,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[246,26,246,27],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[246,28,246,40],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[250,13,250,31],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[250,32,250,46],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[250,47,250,48],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[250,49,250,63],\"els\":[\"0:24\"]},{\"tk\":[253,13,253,31],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[253,32,253,42],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[253,43,253,44],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[253,45,253,47],\"els\":[\"0:58:1274-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[254,18,254,20],\"els\":[\"0:58:1298-1464\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[254,22,254,36],\"els\":[\"0:24\"]},{\"tk\":[254,37,254,38],\"els\":[\"0:58:1305-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[254,39,254,57],\"els\":[\"0:58:1318-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[254,58,254,72],\"els\":[\"0:58:1318-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[257,13,257,15],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[257,24,257,25],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[257,26,257,44],\"els\":[\"0:58:1356-1370\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[257,45,257,59],\"els\":[\"0:58:1356-1370\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[258,15,258,21],\"els\":[\"0:58:1112-1139\"]},{\"tk\":[258,22,258,23],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[258,24,258,27],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[261,13,261,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[261,24,261,25],\"els\":[\"0:58:1342-1384\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[261,26,261,32],\"els\":[\"0:58:1112-1139\"]},{\"tk\":[264,13,264,31],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[264,32,264,46],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[264,47,264,48],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[264,49,264,63],\"els\":[\"0:24\"]},{\"tk\":[267,13,267,31],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[267,32,267,42],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[267,43,267,44],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[267,45,267,47],\"els\":[\"0:58:1444-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[268,18,268,20],\"els\":[\"0:58:1468-1623\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[268,22,268,36],\"els\":[\"0:24\"]},{\"tk\":[268,37,268,38],\"els\":[\"0:58:1475-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[268,39,268,57],\"els\":[\"0:58:1488-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[268,58,268,72],\"els\":[\"0:58:1488-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[271,13,271,15],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[271,28,271,29],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[271,30,271,44],\"els\":[\"0:24\"]},{\"tk\":[272,15,272,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[272,26,272,27],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[272,28,272,31],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[276,13,276,31],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[276,32,276,46],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[276,47,276,48],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[276,49,276,63],\"els\":[\"0:24\"]},{\"tk\":[279,13,279,31],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[279,32,279,42],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[279,43,279,44],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[279,45,279,47],\"els\":[\"0:58:1612-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[283,13,283,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[283,24,283,25],\"els\":[\"0:58:1640-1662\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[283,26,283,29],\"els\":[\"0:58:1653-1662\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,9,292,27],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,28,292,35],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,36,292,38],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,39,292,54],\"els\":[\"0:28\"]},{\"tk\":[292,55,292,56],\"els\":[\"0:58:1759-1790\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,57,292,58],\"els\":[\"0:58:1772-1790\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[292,65,292,75],\"els\":[\"0:58:936-946\"]},{\"tk\":[295,22,295,23],\"els\":[\"0:58:1815-1829\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58:1876-1890\"]},{\"tk\":[295,24,295,29],\"els\":[\"0:58:1815-1829\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[295,30,295,48],\"els\":[\"0:58:1821-1828\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[295,49,295,56],\"els\":[\"0:58:1821-1828\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[296,9,296,11],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[296,26,296,27],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[296,28,296,35],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[297,11,297,13],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[297,28,297,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[297,31,297,34],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[298,13,298,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[298,31,298,39],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[298,40,298,41],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\",\"0:58:1797-1830\"]},{\"tk\":[298,42,298,43],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[300,13,300,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[300,31,300,39],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[300,40,300,41],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\",\"0:58:1797-1830\"]},{\"tk\":[300,42,300,44],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[303,11,303,28],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[303,29,303,37],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[303,38,303,39],\"els\":[\"0:58::34#out:2\",\"0:58:1797-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[303,40,303,52],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[307,9,307,26],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[307,27,307,30],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[307,31,307,32],\"els\":[\"0:58::34#out:3\",\"0:58:1835-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[307,33,307,51],\"els\":[\"0:58:1841-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[307,52,307,62],\"els\":[\"0:58:1841-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[310,9,310,27],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[310,28,310,35],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[310,36,310,38],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[314,9,314,26],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[314,27,314,35],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[314,36,314,37],\"els\":[\"0:58::34#out:2\",\"0:58:1916-1936\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[314,38,314,40],\"els\":[\"0:58:1927-1936\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[317,9,317,26],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[317,27,317,30],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[317,31,317,32],\"els\":[\"0:58::34#out:3\",\"0:58:1941-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[317,33,317,51],\"els\":[\"0:58:1947-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[317,52,317,62],\"els\":[\"0:58:1947-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[321,5,321,7],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[321,11,321,14],\"els\":[\"0:20::110\"]},{\"tk\":[321,15,321,16],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,17,321,21],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,23,321,25],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,26,321,28],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,29,321,30],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,31,321,34],\"els\":[\"0:20::110\"]},{\"tk\":[321,35,321,36],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,37,321,38],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,44,321,47],\"els\":[\"0:20::110\"]},{\"tk\":[321,48,321,49],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,50,321,53],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[321,55,321,57],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[321,58,321,59],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[337,7,337,9],\"els\":[\"0:58:676-1961\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[337,12,337,26],\"els\":[\"0:24\"]},{\"tk\":[337,27,337,29],\"els\":[\"0:58:680-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[337,30,337,48],\"els\":[\"0:58:694-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[337,49,337,63],\"els\":[\"0:58:694-708\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[337,65,337,67],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[338,12,338,29],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[338,30,338,36],\"els\":[\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[338,37,338,39],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[338,40,338,42],\"els\":[\"0:58:713-719\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[343,9,343,11],\"els\":[\"0:58:885-912\"]},{\"tk\":[343,12,343,13],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[343,14,343,28],\"els\":[\"0:24\"]},{\"tk\":[343,29,343,30],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[343,46,343,64],\"els\":[\"0:58:898-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[343,65,343,79],\"els\":[\"0:58:898-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[344,9,344,11],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[344,13,344,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[344,16,344,17],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[344,18,344,32],\"els\":[\"0:24\"]},{\"tk\":[345,11,345,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[345,14,345,15],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[345,16,345,19],\"els\":[\"0:58:885-912\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,9,348,11],\"els\":[\"0:58:847-1701\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,14,348,28],\"els\":[\"0:24\"]},{\"tk\":[348,29,348,30],\"els\":[\"0:58:851-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,31,348,49],\"els\":[\"0:58:864-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,50,348,64],\"els\":[\"0:58:864-878\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,66,348,68],\"els\":[\"0:58:884-926\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[348,70,348,72],\"els\":[\"0:58:885-912\"]},{\"tk\":[348,73,348,74],\"els\":[\"0:58:884-926\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[349,14,349,23],\"els\":[\"0:58:917-925\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[351,11,351,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[351,14,351,15],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[351,16,351,26],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[351,27,351,28],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[351,44,351,58],\"els\":[\"0:24\"]},{\"tk\":[352,11,352,13],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[352,15,352,25],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[352,26,352,27],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[352,28,352,42],\"els\":[\"0:24\"]},{\"tk\":[352,43,352,44],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[352,45,352,55],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[353,13,353,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[353,16,353,17],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[353,18,353,21],\"els\":[\"0:58:950-969\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[356,11,356,21],\"els\":[\"0:58:936-946\"]},{\"tk\":[356,22,356,23],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[356,24,356,26],\"els\":[\"0:58:885-912\"]},{\"tk\":[356,27,356,28],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[356,44,356,62],\"els\":[\"0:58:973-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[356,63,356,77],\"els\":[\"0:58:973-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[357,11,357,13],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[357,15,357,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[357,26,357,27],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[357,28,357,30],\"els\":[\"0:58:885-912\"]},{\"tk\":[358,13,358,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[358,24,358,25],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[358,26,358,38],\"els\":[\"0:58:949-987\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[362,11,362,29],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[362,30,362,44],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[362,45,362,46],\"els\":[\"0:58:997-1024\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[362,47,362,61],\"els\":[\"0:24\"]},{\"tk\":[365,11,365,29],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[365,30,365,40],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[365,41,365,42],\"els\":[\"0:58:1034-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[365,43,365,45],\"els\":[\"0:58:1047-1056\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[367,11,367,21],\"els\":[\"0:58:936-946\"]},{\"tk\":[367,22,367,23],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58:1356-1383\"]},{\"tk\":[367,24,367,42],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[367,43,367,57],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[367,58,367,59],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[368,13,368,27],\"els\":[\"0:24\"]},{\"tk\":[369,11,369,13],\"els\":[\"0:58:885-912\"]},{\"tk\":[369,14,369,15],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[369,16,369,26],\"els\":[\"0:58:936-946\"]},{\"tk\":[370,11,370,13],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[370,15,370,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[370,26,370,27],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[370,28,370,46],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[370,47,370,61],\"els\":[\"0:58:1112-1126\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[371,13,371,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[371,16,371,17],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[371,18,371,21],\"els\":[\"0:58:1112-1139\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,11,374,13],\"els\":[\"0:58:1071-1294\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,16,374,30],\"els\":[\"0:24\"]},{\"tk\":[374,31,374,32],\"els\":[\"0:58:1078-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,33,374,51],\"els\":[\"0:58:1091-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,52,374,66],\"els\":[\"0:58:1091-1105\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,68,374,70],\"els\":[\"0:58:1111-1153\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[374,72,374,74],\"els\":[\"0:58:885-912\"]},{\"tk\":[374,75,374,76],\"els\":[\"0:58:1111-1153\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[375,16,375,25],\"els\":[\"0:58:1144-1152\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[378,13,378,15],\"els\":[\"0:58:885-912\"]},{\"tk\":[378,16,378,17],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[378,18,378,28],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[378,29,378,30],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[378,46,378,64],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[378,65,378,79],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,13,379,15],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,17,379,27],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,28,379,29],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,30,379,48],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,49,379,63],\"els\":[\"0:58:1186-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,64,379,65],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[379,66,379,76],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[380,15,380,17],\"els\":[\"0:58:885-912\"]},{\"tk\":[380,18,380,19],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[380,20,380,23],\"els\":[\"0:58:1177-1200\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[383,13,383,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[383,24,383,25],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[383,26,383,28],\"els\":[\"0:58:885-912\"]},{\"tk\":[383,29,383,30],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[383,46,383,60],\"els\":[\"0:24\"]},{\"tk\":[384,13,384,15],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[384,17,384,27],\"els\":[\"0:58:936-946\"]},{\"tk\":[384,28,384,29],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[384,30,384,32],\"els\":[\"0:58:885-912\"]},{\"tk\":[385,15,385,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[385,26,385,27],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[385,28,385,40],\"els\":[\"0:58:1176-1214\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[389,13,389,31],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[389,32,389,46],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[389,47,389,48],\"els\":[\"0:58:1224-1251\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[389,49,389,63],\"els\":[\"0:24\"]},{\"tk\":[392,13,392,31],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[392,32,392,42],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[392,43,392,44],\"els\":[\"0:58:1261-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[392,45,392,47],\"els\":[\"0:58:1274-1283\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[393,18,393,20],\"els\":[\"0:58:1298-1464\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[393,22,393,36],\"els\":[\"0:24\"]},{\"tk\":[393,37,393,38],\"els\":[\"0:58:1305-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[393,39,393,57],\"els\":[\"0:58:1318-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[393,58,393,72],\"els\":[\"0:58:1318-1332\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[396,13,396,15],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[396,28,396,29],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[396,30,396,48],\"els\":[\"0:58:1356-1370\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[396,49,396,63],\"els\":[\"0:58:1356-1370\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[397,15,397,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[397,26,397,27],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[397,28,397,31],\"els\":[\"0:58:1356-1383\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[401,13,401,31],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[401,32,401,46],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[401,47,401,48],\"els\":[\"0:58:1394-1421\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[401,49,401,63],\"els\":[\"0:24\"]},{\"tk\":[404,13,404,31],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[404,32,404,42],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[404,43,404,44],\"els\":[\"0:58:1431-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[404,45,404,47],\"els\":[\"0:58:1444-1453\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[405,18,405,20],\"els\":[\"0:58:1468-1623\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[405,22,405,36],\"els\":[\"0:24\"]},{\"tk\":[405,37,405,38],\"els\":[\"0:58:1475-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[405,39,405,57],\"els\":[\"0:58:1488-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[405,58,405,72],\"els\":[\"0:58:1488-1502\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[408,13,408,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[408,24,408,25],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[408,26,408,40],\"els\":[\"0:24\"]},{\"tk\":[408,41,408,42],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[409,15,409,33],\"els\":[\"0:58:1538-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[409,34,409,48],\"els\":[\"0:58:1538-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[410,13,410,15],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[410,17,410,27],\"els\":[\"0:58:936-946\"]},{\"tk\":[410,28,410,29],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[410,30,410,44],\"els\":[\"0:24\"]},{\"tk\":[411,15,411,25],\"els\":[\"0:58:936-946\"]},{\"tk\":[411,26,411,27],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[411,28,411,31],\"els\":[\"0:58:1525-1552\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[415,13,415,31],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[415,32,415,46],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[415,47,415,48],\"els\":[\"0:58:1562-1589\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[415,49,415,63],\"els\":[\"0:24\"]},{\"tk\":[418,13,418,31],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[418,32,418,42],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[418,43,418,44],\"els\":[\"0:58:1599-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[418,45,418,47],\"els\":[\"0:58:1612-1621\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[422,13,422,23],\"els\":[\"0:58:936-946\"]},{\"tk\":[422,24,422,25],\"els\":[\"0:58:1640-1662\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[422,26,422,29],\"els\":[\"0:58:1653-1662\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,9,431,27],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,28,431,35],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,36,431,38],\"els\":[\"0:58:1738-1791\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,39,431,54],\"els\":[\"0:28\"]},{\"tk\":[431,55,431,56],\"els\":[\"0:58:1759-1790\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,57,431,58],\"els\":[\"0:58:1772-1790\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[431,65,431,75],\"els\":[\"0:58:936-946\"]},{\"tk\":[434,22,434,23],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[434,24,434,29],\"els\":[\"0:58:1815-1829\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[434,30,434,48],\"els\":[\"0:58:1821-1828\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[434,49,434,56],\"els\":[\"0:58:1821-1828\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[435,9,435,11],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[435,26,435,27],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[435,28,435,35],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[436,11,436,13],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[436,28,436,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[436,31,436,34],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[437,13,437,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[437,31,437,39],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[437,40,437,41],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\",\"0:58:1797-1830\"]},{\"tk\":[437,42,437,43],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[439,13,439,30],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[439,31,439,39],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\"]},{\"tk\":[439,40,439,41],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\",\"0:58::34#out:2\",\"0:58:1797-1830\"]},{\"tk\":[439,42,439,44],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[442,11,442,28],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[442,29,442,37],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[442,38,442,39],\"els\":[\"0:58::34#out:2\",\"0:58:1797-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[442,40,442,52],\"els\":[\"0:58:1808-1830\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[446,9,446,26],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[446,27,446,30],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[446,31,446,32],\"els\":[\"0:58::34#out:3\",\"0:58:1835-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[446,33,446,51],\"els\":[\"0:58:1841-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[446,52,446,62],\"els\":[\"0:58:1841-1851\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,9,449,27],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,28,449,35],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,36,449,38],\"els\":[\"0:58:1856-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,39,449,44],\"els\":[\"0:58:1876-1890\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,45,449,63],\"els\":[\"0:58:1882-1889\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[449,64,449,71],\"els\":[\"0:58:1882-1889\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[453,9,453,26],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[453,27,453,35],\"els\":[\"0:58::34#out:2\"]},{\"tk\":[453,36,453,37],\"els\":[\"0:58::34#out:2\",\"0:58:1916-1936\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[453,38,453,40],\"els\":[\"0:58:1927-1936\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[456,9,456,26],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[456,27,456,30],\"els\":[\"0:58::34#out:3\"]},{\"tk\":[456,31,456,32],\"els\":[\"0:58::34#out:3\",\"0:58:1941-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[456,33,456,51],\"els\":[\"0:58:1947-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[456,52,456,62],\"els\":[\"0:58:1947-1957\",\"0:58::34\",\"0:58::38\",\"0:58\"]},{\"tk\":[462,3,462,26],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[462,27,462,50],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[462,50,462,51],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[462,51,462,52],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[462,54,462,55],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[463,6,463,24],\"els\":[\"0:22\"]},{\"tk\":[463,24,463,25],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[463,25,463,26],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[463,28,463,29],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[463,30,463,32],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[464,3,464,26],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[464,27,464,50],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[464,50,464,51],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[464,51,464,52],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[464,54,464,55],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[465,6,465,24],\"els\":[\"0:22\"]},{\"tk\":[465,24,465,25],\"els\":[\"0:22\",\"0:58::38\",\"0:58\"]},{\"tk\":[465,25,465,26],\"els\":[\"0:58::38\",\"0:58\",\"0:22\"]},{\"tk\":[465,28,465,29],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[465,30,465,32],\"els\":[\"0:58::38\",\"0:58\"]},{\"tk\":[468,4,468,16],\"els\":[\"0:19\"]},{\"tk\":[468,17,468,18],\"els\":[\"0:19\"]},{\"tk\":[468,19,468,36],\"els\":[\"0:19\"]},{\"tk\":[468,37,468,45],\"els\":[\"0:19\"]},{\"tk\":[471,4,471,11],\"els\":[\"0:31\"]},{\"tk\":[471,12,471,13],\"els\":[\"0:31\"]},{\"tk\":[471,14,471,31],\"els\":[\"0:31\"]},{\"tk\":[471,32,471,35],\"els\":[\"0:31\"]},{\"tk\":[492,3,492,21],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[492,22,492,38],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[492,39,492,40],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[492,41,492,72],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[493,3,493,21],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[493,22,493,50],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[493,51,493,52],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[493,53,493,55],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[494,3,494,21],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[494,22,494,43],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[494,44,494,45],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[494,46,494,77],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[495,3,495,20],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[495,21,495,27],\"els\":[\"0:20::156#out:2\"]},{\"tk\":[495,28,495,29],\"els\":[\"0:20::156#out:2\",\"0:20\",\"0:20::156\"]},{\"tk\":[495,30,495,32],\"els\":[\"0:20\",\"0:20::156\"]},{\"tk\":[499,3,499,21],\"els\":[\"0:58:425-436\",\"0:58\",\"0:58::34\"]},{\"tk\":[499,22,499,29],\"els\":[\"0:58:425-436\",\"0:58\",\"0:58::34\"]},{\"tk\":[499,30,499,31],\"els\":[\"0:58:425-436\",\"0:58\",\"0:58::34\"]},{\"tk\":[499,32,499,35],\"els\":[\"0:58:425-436\",\"0:58\",\"0:58::34\"]},{\"tk\":[502,3,502,21],\"els\":[\"0:58:475-501\",\"0:58\",\"0:58::34\"]},{\"tk\":[502,22,502,36],\"els\":[\"0:58:475-501\",\"0:58\",\"0:58::34\"]},{\"tk\":[502,37,502,38],\"els\":[\"0:58:475-501\",\"0:58\",\"0:58::34\"]},{\"tk\":[502,39,502,42],\"els\":[\"0:58:492-501\",\"0:58\",\"0:58::34\"]},{\"tk\":[507,3,507,21],\"els\":[\"0:58:647-669\",\"0:58\",\"0:58::34\"]},{\"tk\":[507,22,507,32],\"els\":[\"0:58:647-669\",\"0:58\",\"0:58::34\"]},{\"tk\":[507,33,507,34],\"els\":[\"0:58:647-669\",\"0:58\",\"0:58::34\"]},{\"tk\":[507,35,507,37],\"els\":[\"0:58:660-669\",\"0:58\",\"0:58::34\"]}]}}}","blocks":[{"RTWName":"<Root>/SpindelPos","SIDString":"RealTimeMachine:24"},{"RTWName":"<Root>/CountFactor","SIDString":"RealTimeMachine:28"},{"RTWName":"<Root>/System_Trigger","SIDString":"RealTimeMachine:22"},{"RTWName":"<S1>:2","SIDString":"RealTimeMachine:20:2"},{"RTWName":"<S1>:101","SIDString":"RealTimeMachine:20:101"},{"RTWName":"<S1>:100","SIDString":"RealTimeMachine:20:100"},{"RTWName":"<S1>:98","SIDString":"RealTimeMachine:20:98"},{"RTWName":"<S1>:1","SIDString":"RealTimeMachine:20:1"},{"RTWName":"<S1>:12","SIDString":"RealTimeMachine:20:12"},{"RTWName":"<S1>:9","SIDString":"RealTimeMachine:20:9"},{"RTWName":"<S1>:108","SIDString":"RealTimeMachine:20:108"},{"RTWName":"<S1>:103","SIDString":"RealTimeMachine:20:103"},{"RTWName":"<S1>:104","SIDString":"RealTimeMachine:20:104"},{"RTWName":"<Root>/Constant","SIDString":"RealTimeMachine:59"},{"RTWName":"<S2>:1","SIDString":"RealTimeMachine:58:1"},{"RTWName":"<Root>/DesSteps","SIDString":"RealTimeMachine:19"},{"RTWName":"<Root>/Dir","SIDString":"RealTimeMachine:31"},{"RTWName":"<Root>/Chart","SIDString":"RealTimeMachine:20"},{"RTWName":"<Root>/MATLAB Function","SIDString":"RealTimeMachine:58"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};